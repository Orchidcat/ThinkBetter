#project/键盘 


## Metadata
name 可以签名


## Units

U: 19.05 # 19.05mm MX spacing
u: 19 # 19mm MX spacing
cx: 18 # 18mm Choc X spacing
cy: 17 # 17mm Choc Y spacing

内部变量
`$default_stagger: 0,
$default_spread: 'u',
$default_splay: 0,
$default_height: 'u-1',
$default_width: 'u-1',
$default_padding: 'u',
$default_autobind: 10`

`





## Points

一个点，代表一个2D(x,y)，并且具有选装方向 r，以及其他的一些元数据。这些可以被认为是最终键盘布局中键帽的中间点，并额外处理了键帽的角度，再加上一些元数据（如名称、行/列信息、自定义变量等）。

X 值向右为正，向左为负，而 Y 值向上为正，向下为负。此外，旋转表示 Y 轴的方向，其变化是逆时针进行的（因此 +90° 向左旋转，而 -90° 向右旋转）。在本文档中，我们经常以 [x, y, r°] 的形式引用点。


![[Pasted image 20251010083506.png|400]]


点是键盘创建的重要组成部分，因为它们稍后可用于定位形状（形成电路板轮廓）和 PCB 封装 - **可选择使用过滤器仅使用子集**。


### Anchors
其中一种替代方法是使用锚点，我们不直接指定点的 x/y/r 坐标，而是通过一些平移/旋转/调整从已经存在的起点计算它们。

`string`  串意味着它只是对具有该名称的现有点的引用，无需任何进一步的修改。
`array`   它是一个由多个部分组成的锚点（或称多锚点），每个元素本身就是一个锚点，以递归的方式呈现。但你可能会问，为什么一个点需要多个锚点呢？因为每个子锚点都会成为下一个子锚点的起点。
`object`  这是一个完整的锚声明

#### Attributes
在完整的对象锚点声明中，可以使用以下字段：

- **ref**  是锚点执行附加修改的起点。此字段本身会被递归解析为一个锚点。因此，最简单的形式是，它可以是一个字符串，用于通过名称指定现有的起点（稍后会详细介绍名称），但如果需要，也可以是一个完整的嵌套锚点。
- **aggregate**  当需要将多个位置组合作为进一步调整的起点时，它是 ref 的替代方案。它们互斥，因此我们可以在任何给定的锚点中使用 ref 或 aggregate。aggregate 字段始终是一个对象，包含：
	- **parts** 包含我们想要聚合的子锚点的数组
	- **method** 字符串来指示我们如何聚合它们。
	  到目前为止实现的唯一方法是`average`，无论如何这是默认方法，因此现在可以省略该方法。
- **orient** 是一种预旋转，意味着它发生在任何移位操作之前；仅影响我们正在计算的点的 r 值。
	- **number** 该数字只是添加到正在进行的点计算的当前旋转中
	- **sub-anchor** 在这种情况下，该点“转向”我们参考的点（意味着如果从该点投射一条线，则其旋转将精确地设置为击中该点）。
- **shift**  用于在 XY 平面上移动（或者更正式地说，平移）点。
	- 一个由两个数字组成的数组，分别指定 x 和 y 偏移
	- 一个数字，它将被解析为 [number, number]。
- **rotate**  是平移后的一种后旋转，与旋转前的定向方式相反。除此之外，其工作原理完全相同。
- **affect**   可以指定在当前锚点计算期间要影响的字段的覆盖。
	- 仅包含字符 x、y 或 r 子集的字符串；
	- 仅包含单字母字符串“x”、“y”或“r”子集的数组。
- **resist**  表示我们不希望对镜像点给予特殊待遇。我们将在稍后讨论镜像，但从锚点的角度来看，我们需要知道的是，对于镜像点，移动和定向/旋转都是镜像的，以保持对称。因此，如果我们在镜像点上指定 [1, 1] 的移位，则实际应用的是 [-1, 1]，并且在这些情况下旋转也是顺时针（读作逆时针）。但是如果我们不想要这种行为，（比如，因为 PCB 封装位于电路板的同一面，朝上，无论哪一半）我们可以抵制这种特殊处理。

### Zones
定义批量点的方法；一组列构成一个区域。可以设置任意数量的区域；在列中，**行默认是从下到上构建**。

继承顺序如下：
1. 内置的硬编码默认值
2. 全局`points.key`覆盖
3. 区域范围`points.zones.<zone_name>.key`覆盖
4. 列范围`points.zones.<zone_name>.columns.<column_name>.key`覆盖
5. 行范围`points.zones.<zone_name>.rows.<row_name>`覆盖
6. 特定于键的`points.zones.<zone_name>.columns.<column_name>.rows.<row_name>`覆盖

#### keys

- **stagger**  列错位是指相对于前一列，在垂直方向上向整列的起始点进行额外的偏移（初始值为 0，之后累加）。其默认值为 0（也可以使用内部变量 $default_stagger 覆盖）。
- **padding**  一旦确定了列中的某个点，padding 就表示该点与下一行之间的垂直间隙。其默认值为 u（也可以使用 $default_padding 内部变量覆盖）
- **`orient`** / **`shift`** / **`rotate`** 当前键定向（默认值 = 0）、移动（默认值 = [0, 0]）和旋转（默认值 = 0），这样做不仅可以定位自身，还可以为列中的下一行提供起点
- **adjust**  该字段也用于调整单个点 - 但是，与上述三者相反，它被解析为实际锚点，并且独立应用，仅影响当前键而不影响累积列布局。
- **bind**  表示每个键在尝试与相邻键绑定以形成连续形状时所具有的方向“到达”量。
- **autobind**  启用自动分配相关方向的绑定，以组合传统的键槽。更深入的解释，请参阅“轮廓”部分。其默认值为 10（也可以使用 $default_autobind 内部变量覆盖）。
- **skip**  该字段表示当前点只是一个“辅助点”，不应包含在输出中。当一个真实点更容易通过“垫脚石”计算出来，但我们实际上并不希望垫脚石本身成为关键点时，就会发生这种情况。当然，默认值为 false。
- **asym** 确定按键应位于键盘的哪一侧（参见镜像）。其默认值为两侧。
- **mirror** 提供一种方法来覆盖镜像键的任何键级属性（请参阅镜像）。默认为空。
- **colrow** 内置便捷变量，用于存储列和行的连接名称，唯一标识区域内的键。其值为 `{{col.name}}_{{row}}`，通过模板构建
- **name** 键的名称，用于在区域内以及全局范围内唯一标识该键。其默认值为 `{{zone.name}}_{{colrow}}`，通过模板构建
- **width/height**  辅助值用于表示当前位置的键帽宽度/高度。
```note-caution
这些值仅适用于计算出的关键位置的演示表示。有关要剪切的实际轮廓（或用作案例基础），请参阅 'layout' 部分。
```


### adjustment

完成特定区域的定义后，我们可以调整各个区域的整体设置，甚至可以调整所有区域。

- **rotate**  可以将角度应用于所有相关点，最常用于模拟单片板的半角。如果在区域级别指定，则仅适用于该区域的点；如果在全局级别指定，则适用于所有点。旋转的原点始终被假定为`[0, 0]`。这对于全局旋转来说无关紧要，但对于区域级旋转则应予以考虑。
- **mirror**  由于 Ergogen 的默认方向是从左到右，这通常意味着棋盘的左侧。但棋盘通常有两面，因此为了省去我们在右侧复制所有内容的工作，Ergogen 提供了一种沿轴自动镜像“源”点的方法。如果该`mirror`字段为数字，则它将用作镜像轴的 x 坐标。否则，它将被视为带有附加`distance`字段的锚点，其中锚点定义任意参考点，并`distance`定义它与最终镜像的距离。与旋转一样，镜像可以应用于单个区域，也可以在最后同时应用于所有区域，具体取决于`mirror`我们使用上述两个声明中的哪一个。


## Outlines

外围轮廓
通过选择任意点子集并将形状放置在那里形成一个部分来实现这一点，然后使用布尔运算（即加法、减法或交集）将各部分组合成最终的轮廓以进行导出。


### Binding
各个开关孔相互延伸（或_绑定_）。可以将其视为一种“邻居声明”，告诉 Ergogen 应该向哪个方向扩展（以及扩展多少）才能到达下一个点。

````
bind: num | [num_x, num_y] | [num_t, num_r, num_b, num_l] # defer to autobind by default
````

### Filtering
过滤是 Ergogen 在放置当前形状时决定使用哪些点的方式。毕竟，点部分可能包含许多区域、多种_类型_的点、安装孔辅助点或一次性 PCB 封装等等。因此，能够轻松地从这些点中选择子集会非常方便。

undefined: `[0, 0, 0°]`
boolean: true,就是使用所有point
string：代表一个单一的过滤器
object：将被解析为一个锚点，单独解析
array：一个复杂的过滤器


每个过滤器实际上由三个组件组成：

- 要检查哪些关键级别属性， 
- 如何检查它们，
- 以及 要检查它们的哪些值。


### Parts

#### common attributes

- what     放置什么形状
- where   声明我们想要放置这些形状的位置——这是我们可以使用前面讨论过的过滤器的地方。
- operation   指示我们希望当前部分如何与先前部分的累积结果相结合
	- add    生成一个并集——这是默认操作。
	- subtract   从正在进行的结果中减去这部分
	- intersect   计算该部分与正在进行的结果的交集。
	- stack    只是将当前部分绘制在正在进行的结果“之上”（可能跨越线而不是计算并集）。
	- bound   布尔值，表示我们是否要激活形状上的绑定。如果为 false，则形状按原样放置。如果为 true，则将相应的绑定矩形添加到每个形状的各个相关边，并将结果合并。
	- asym    该字段与 where 过滤器配套使用，表示过滤如何处理镜像点。可用的值与我们在镜像部分讨论过的相同——标准选项为 source/clone/both。
	- adjust   用于调整每个形状位置的相对锚点 - 类似于键级调整属性。
	- scale    可选乘数，用于缩放结果形状。默认值为 1，表示不缩放。
	- expand   以毫米为单位的数字，用于扩大（或缩小，如果数字为负）当前轮廓。与缩放不同，它绘制起始形状的外部（或内部）“轮廓”，因此通常也会改变形状本身，而不仅仅是其大小。
	- joints   扩展的伴侣，指定在扩展/收缩期间对接头应用哪种类型的处理。
	- fillet    此数字（如果大于默认值零）会触发对（几乎）完成的部分的圆角操作，并使用给定的半径将其角圆化。如果半径大于角的任一相邻线段，则跳过该角。



#### Shapes
- rectangle 矩形图元
	- size 
	- bevel     矩形的可选斜角，默认为`0`
	- corner
- circle
- poly
- outline











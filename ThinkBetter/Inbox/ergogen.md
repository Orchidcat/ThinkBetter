#project/键盘 


## Points

一个点，代表一个2D(x,y)，并且具有选装方向 r，以及其他的一些元数据。这些可以被认为是最终键盘布局中键帽的中间点，并额外处理了键帽的角度，再加上一些元数据（如名称、行/列信息、自定义变量等）。

X 值向右为正，向左为负，而 Y 值向上为正，向下为负。此外，旋转表示 Y 轴的方向，其变化是逆时针进行的（因此 +90° 向左旋转，而 -90° 向右旋转）。在本文档中，我们经常以 [x, y, r°] 的形式引用点。


![[Pasted image 20251010083506.png|400]]


点是键盘创建的重要组成部分，因为它们稍后可用于定位形状（形成电路板轮廓）和 PCB 封装 - **可选择使用过滤器仅使用子集**。


### Anchors
其中一种替代方法是使用锚点，我们不直接指定点的 x/y/r 坐标，而是通过一些平移/旋转/调整从已经存在的起点计算它们。

`string`  串意味着它只是对具有该名称的现有点的引用，无需任何进一步的修改。
`array`   它是一个由多个部分组成的锚点（或称多锚点），每个元素本身就是一个锚点，以递归的方式呈现。但你可能会问，为什么一个点需要多个锚点呢？因为每个子锚点都会成为下一个子锚点的起点。
`object`  这是一个完整的锚声明

#### Attributes
在完整的对象锚点声明中，可以使用以下字段：

- **ref**  是锚点执行附加修改的起点。此字段本身会被递归解析为一个锚点。因此，最简单的形式是，它可以是一个字符串，用于通过名称指定现有的起点（稍后会详细介绍名称），但如果需要，也可以是一个完整的嵌套锚点。
- **aggregate**  当需要将多个位置组合作为进一步调整的起点时，它是 ref 的替代方案。它们互斥，因此我们可以在任何给定的锚点中使用 ref 或 aggregate。aggregate 字段始终是一个对象，包含：
	- **parts** 包含我们想要聚合的子锚点的数组
	- **method** 字符串来指示我们如何聚合它们。
	  到目前为止实现的唯一方法是`average`，无论如何这是默认方法，因此现在可以省略该方法。
- **orient** 是一种预旋转，意味着它发生在任何移位操作之前；仅影响我们正在计算的点的 r 值。
	- **number** 该数字只是添加到正在进行的点计算的当前旋转中
	- **sub-anchor** 在这种情况下，该点“转向”我们参考的点（意味着如果从该点投射一条线，则其旋转将精确地设置为击中该点）。
- **shift**  用于在 XY 平面上移动（或者更正式地说，平移）点。
	- 一个由两个数字组成的数组，分别指定 x 和 y 偏移
	- 一个数字，它将被解析为 [number, number]。
- **rotate**  是平移后的一种后旋转，与旋转前的定向方式相反。除此之外，其工作原理完全相同。
- **affect**   可以指定在当前锚点计算期间要影响的字段的覆盖。
	- 仅包含字符 x、y 或 r 子集的字符串；
	- 仅包含单字母字符串“x”、“y”或“r”子集的数组。
- **resist**  表示我们不希望对镜像点给予特殊待遇。我们将在稍后讨论镜像，但从锚点的角度来看，我们需要知道的是，对于镜像点，移动和定向/旋转都是镜像的，以保持对称。因此，如果我们在镜像点上指定 [1, 1] 的移位，则实际应用的是 [-1, 1]，并且在这些情况下旋转也是顺时针（读作逆时针）。但是如果我们不想要这种行为，（比如，因为 PCB 封装位于电路板的同一面，朝上，无论哪一半）我们可以抵制这种特殊处理。

### Zones
定义批量点的方法；


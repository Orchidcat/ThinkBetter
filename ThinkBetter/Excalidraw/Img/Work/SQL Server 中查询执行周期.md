
#SQLServer 

SQLOS完全负责SQL Server的线程调度。

在现代CPU环境中，SQLOS会为每个CPU内核分配一个scheduler程序（SOS）来进行线程管理。（4个八核cpu的机器，SQLOS将产生32个scheduler程序）

![[Pasted image 20220609150430.png]]


### SOS由三部分组成：
- Runnable Queue - 采用严格的先入先出（FIFO）顺序来处理必须处理的线程。从cpu，waiter list过度到runnable queue的线程将唯一队列中的最后一个，并且它必须等待先前移入可运行队列的所有线程（启用资源管理器时，可以覆盖FIFO顺序与启用的调控器一样，资源池优先级可以不同地分配给工作负载组。资源调控器的使用通常很少见）
- CPU - 负责处理线程的物理/逻辑CPU Core. **一次只能处理一个线程**
- Waiter List - 所有处于挂起状态的线程都存储在此。挂起的线程是必须等待资源可供他们使用的线程。在等待列表中的线程并**没有强加的限制时间**。但，当查询执行会话超时，此线程将在等待列表中取消。

### 线程的三种状态
- **RUNNING** - 线程正在CPU中执行。
- **SUSPENDED** - 线程请求资源不可用，在Waiter List中等待。
- **RUNNABLE** - 请求资源可用，移入到Runnable Queue中。



### Schedule 程序的2种工作方式
- 一个线程运行三种状态来完成用户发出的请求
	- ![[Pasted image 20220609151423.png|400x350]]
	- 正在运行的线程 5 尝试访问在请求时不可用的所需资源。因此，线程 5 的状态变为挂起，并移至等待列表。线程 5 将保持挂起状态，直到需要的资源可用为止，并且线程在等待者列表中停留的时间没有时间限制（等待者列表中的线程数也不受限制）。当所需资源可用时，线程 5 将被推送到可运行队列以等待处理器可用。一旦处理器变得可用，线程 5 将完成请求（如果它需要另一个它必须等待的不可用资源，则将重复该序列）
- 一个线程运行两种状态来完成用户发出的请求
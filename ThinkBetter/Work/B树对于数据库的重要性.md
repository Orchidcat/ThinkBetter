#SQLServer 

B 树解决了一个根本性问题：当磁盘访问速度比内存访问慢数千倍时，如何高效地查找磁盘上的数据。

**所有主流数据库都使用 B 树（或 B+ 树）作为索引。**
### 磁盘上的二叉搜索树



内存中的二叉树
![[Pasted image 20251128085125.png|300]]

查找一个键需要 O(log₂ n) 次比较。
对于 100 万条记录，平衡二叉搜索树的高度为 log₂(1,000,000) ≈ 20。也就是说，需要进行 20 次比较才能找到任何一条记录。在内存中大约是0.002毫秒。

但这在磁盘上操作就是灾难；

==磁盘IO成本过高==
按照数据块的读取（4KB到16KB） **磁盘速度比内存慢 100 到 100,000 倍。**

==二叉树灾难==
  在磁盘上存储二叉搜索树时，每个节点都存储在单独的磁盘块中。从父节点遍历到子节点需要进行磁盘寻道。

针对 100 万条记录：

- 高度：20 个节点
- 磁盘寻道次数：20
- 硬盘读取时间：20 × 10 毫秒 = **200 毫秒**
- SSD 耗时：20 × 0.1 毫秒 = **2 毫秒**

对于固态硬盘来说，这尚可接受，但对于机械硬盘来说就太糟糕了。而且随着硬盘体积增大，情况还会更糟。

针对10亿条记录：
- 高度：30 个节点
- 硬盘读写时间：30 × 10 毫秒 = **300 毫秒**
- SSD 耗时：30 × 0.1 毫秒 = **3 毫秒**

**根本问题在于：** 二叉搜索树的扇出度太低（每个节点只有两个子节点）。我们需要增加每个节点的子节点数量来降低树的高度。


### 为什么不直接让树保持平衡呢？

你可能会想：“只要保持树木平衡就行了！”红黑树和AVL树就是这么做的。

问题不仅仅在于树的高度，还在于维护成本。平衡操作需要轮换节点和更新指针。在内存中，这很便宜（只需几次指针写入）。但在磁盘上，成本却很高：

1. 从磁盘读取节点（4 KB 数据块）
2. 修改内存中的节点
3. 将修改后的节点写回磁盘（4 KB 块）
4. 更新父指针（更多磁盘 I/O）

对于频繁插入和删除操作的树状数据结构，持续的重新平衡会严重影响性能。我们需要一种数据结构，它：

- 高扇出度（每个节点子节点数量多）→ 降低高度
- 需要不频繁的重新平衡 → 降低 I/O 开销

这种数据结构就是 B 树。

## 什么是B树？

B树是一种针对磁盘访问优化的自平衡树。与每个节点只有两个子节点（二叉树）不同，B树节点可以有**成百上千**个子节点。

**核心思想：** 每个 B 树节点都适合放在一个磁盘块中（4 KB 到 16 KB）。既然无论如何我们都必须读取整个磁盘块，那么就尽可能多地将键值打包到该磁盘块中。

### B树结构

B树节点存储：

- **N 个键**（已排序）
- **N + 1 个指向**子节点的指针

每个键都起到分隔符的作用：c​​hild[i] 中的键小于 key[i]，child[i+1] 中的键大于或等于 key[i]。

![[Pasted image 20251128091845.png|500]]

扇出约为 100 的 B 树。根节点有 2 个键和 3 个子节点。内部节点有 4 个键和 5 个子节点。叶节点包含实际数据。


### B树层次结构

B树有三种类型的节点：

**根节点：** 树的顶部。每个节点只有一个根节点。
**内部节点：** 用于指导搜索的中间层。它们存储分隔符键和指针，但不存储实际数据。
**叶节点：** 最底层，包含实际数据（键值对）。所有叶节点深度相同。

这是**B+树**，也是最常见的B树变体。B+树只在叶子节点存储数据，而B树也可以在内部节点存储数据。所有主流数据库都使用B+树，但为了简便起见，通常称之为“B树”。


### 为什么高扇出很重要

**二叉树（扇出=2）：**

- 100万条记录 → 高度 = 20
- 10亿条记录 → 高度 = 30

**B树（扇出=100）：**

- 100万条记录 → 高度 = 3（因为 100³ = 1,000,000）
- 10亿条记录 → 高度 = 5（因为 100⁵ = 10,000,000,000）

**B树（扇出=1000）：**

- 100万条记录 → 高度 = 2（因为 1000² = 1,000,000）
- 10亿条记录 → 高度 = 3（因为1000³ = 1,000,000,000）


![[Pasted image 20251128092050.png|500]]

**高扇出 = 更少的磁盘寻道次数 = 更快的查询速度。**


## B树查找算法

在 B 树中查找键值需要从根节点到叶节点进行遍历，并在每个节点进行二分查找。

**算法：**

1. 从根节点开始
2. 对当前节点中的键进行二分查找，以找到分隔符键范围。
3. 跟随相应的子指针
4. 重复此步骤直至到达叶节点。
5. 在叶子中，要么找到密钥，要么得出结论：密钥不存在。

**时间复杂度：**

- 树的高度：O(log_fanout n)
- 每个节点的二分查找复杂度：O(log₂扇出)
- 总计：O(log n)



## B树性能特征

### 查找复杂度

**时间复杂度：** O(log n)

对于具有 n 个键和 f 个扇出值的树：

- 树高：log_f(n)
- 每个节点的二分查找：log₂(f)
- 总比较次数：log_f(n) × log₂(f) = O(log n)

**磁盘 I/O：** log_f(n) 次磁盘读取（每层一次）

### 插入复杂度

**时间复杂度：** O(log n)

- 查找插入点的时间复杂度：O(log n)
- 插入到叶子节点：O(f) 到 Shift 键
- 必要时拆分：移动键的时间复杂度为 O(f)
- 分裂向上传播：最坏情况下会传播 O(log n) 个层级

**磁盘 I/O：** O(log n) 次磁盘读取 + O(log n) 次磁盘写入

### 删除复杂性

**时间复杂度：** O(log n)

- 查找密钥的时间复杂度：O(log n)
- 从叶子节点删除：O(f) 到 Shift 键
- 如有必要则合并：移动键的时间复杂度为 O(f)。
- 合并操作向上传播：最坏情况下需要 O(log n) 层。

**磁盘 I/O：** O(log n) 次磁盘读取 + O(log n) 次磁盘写入

### 空间复杂性

**空间复杂度：** O(n)

每个键只存储一次。内部节点会增加一些开销（指针和分隔符键），但这通常只占数据大小的 10-20%。

**占用率：** 节点通常占用 50-90%。更高的扇出可以提高空间效率，因为指针开销会相应减少。




## B树的局限性

### 1. 写出放大倍数

每次插入操作都可能触发一直到根目录的拆分。最坏情况下：

- 插入 1 个键 → 拆分叶节点 → 拆分父节点 → 拆分祖父节点 → 拆分根节点
- 一次逻辑写入会变成 4 次以上的物理写入

**例如：**插入 100 万个密钥，并频繁拆分：

- 逻辑写道：100万
- 物理写入次数（含分割）：200万-300万次
- 写入放大倍数：2-3倍

**另一种选择：** RocksDB、Cassandra 和 LevelDB 使用的 LSM 树（日志结构合并树）。LSM 树将数据批量写入内存，然后按顺序刷新到磁盘，避免了原地更新。

### 2. 对非顺序键进行范围查询

B 树针对索引键的范围查询进行了优化，但难以处理多列范围查询。

**例子：**

```
-- Fast: Range query on indexed column
SELECT * FROM orders WHERE order_date BETWEEN ‘2024-01-01’ AND ‘2024-12-31’;
-- B-Tree traverses leaf nodes sequentially (leaf nodes are linked)

-- Slow: Range query on non-indexed column
SELECT * FROM orders WHERE total_amount BETWEEN 100 AND 200;
-- Must scan entire table (no index on total_amount)

-- Slow: Multi-column range query
CREATE INDEX idx_date_amount ON orders(order_date, total_amount);
SELECT * FROM orders WHERE order_date > ‘2024-01-01’ AND total_amount > 100;
-- B-Tree can use order_date range, but must filter total_amount in memory
```

**替代方案：** 多维索引，如 R 树（用于空间数据）或混合索引。

### 3. 缓存的内存开销

为了避免磁盘 I/O 操作，数据库会将频繁访问的 B 树节点缓存在内存中。对于大型数据库：

- 10亿条记录
- 树高：4 层
- 内部节点：约100万个
- 缓存大小：约 16 GB（用于缓存所有内部节点）

**经验法则：** 预留数据库大小的 10-20% 用于 RAM，以用于 B 树缓存。


### 4. 随时间推移而出现的碎片化

经过多次插入和删除操作后，B树节点可能只使用了50-60%的空间。这会浪费空间并增加树的高度。

**解决方案：** 定期执行 VACUUM（PostgreSQL）或 OPTIMIZE TABLE（MySQL）来重建 B 树。

**例子：**

```
-- PostgreSQL: Rebuild table and indexes
VACUUM FULL users;

-- MySQL: Optimize table (rebuilds B-Tree)
OPTIMIZE TABLE users;
```


### 5. 并发挑战

B 树在拆分和合并过程中需要加锁。在高并发工作负载下，锁争用可能导致写入瓶颈。

**解决方案：** 无闩锁 B 树（在 Microsoft SQL Server 等现代数据库中使用）或 MVCC（多版本并发控制）。


## 何时不应使用 B 树

B 树非常适合处理基于磁盘的已排序数据，但并非总是最优选择：

### 写入密集型工作负载

如果你每秒写入 10 万次，读取次数很少，那么 LSM 树的性能优于 B 树。

**比较：**

![[Pasted image 20251128092924.png|500]]

**例如：**

- B树：MySQL、PostgreSQL、SQLite
- LSM-Tree：RocksDB、Cassandra、LevelDB


### 内存数据库

如果你的整个数据集都能装进内存，那么 B 树就会增加不必要的复杂性。哈希索引或跳跃表更简单也更快。
![[Pasted image 20251128092956.png|500]]

**例如：**

- 哈希索引：Memcached、Redis 哈希
- 跳跃列表：Redis 有序集




### 分析工作负载（OLAP）

对于扫描数百万行的大型分析查询，列式存储（例如 Parquet、ORC）的性能优于 B 树。
![[Pasted image 20251128093031.png|500]]
**例如：**

- 行式存储（B树）：MySQL、PostgreSQL
- 列式存储：Parquet（Snowflake、BigQuery 使用）、ORC（Hive 使用）


## 摘要：B型树为何胜出

经过 50 多年的发展，B 树仍然是磁盘上占主导地位的数据结构，原因如下：

- **减少磁盘 I/O：** 高扇出会降低树状结构高度
- **自动平衡：** 拆分和合并操作可保持所有叶片深度一致。
- **支持范围查询：** 排序后的键和叶子级链接可实现高效扫描
- **适用于任何磁盘：** 针对 HDD（顺序 I/O）和 SSD（块级访问）均进行了优化

**关键洞察：** B 树与磁盘存储的限制相匹配。由于最小的 I/O 单元是数据块，B 树会将尽可能多的数据打包到每个数据块中。这种简单的理念——最大化扇出以最小化树的高度——使得数据库运行速度极快。

**何时使用B树：**

- 基于磁盘的存储（数据库索引）
- 经常阅读，适度写作
- 对已排序数据进行范围查询
- 通用OLTP工作负载

**何时考虑替代方案：**

- 写入密集型工作负载（LSM-树）
- 内存数据（哈希索引、跳跃表）
- 分析查询（列式存储）

每次你查询数据库并在几毫秒内获得结果时，都要感谢 B 树。













参考：
[B-Trees: Why Every Database Uses Them - by Mehmet Gökçe](https://mehmetgoekce.substack.com/p/b-trees-why-every-database-uses-them)



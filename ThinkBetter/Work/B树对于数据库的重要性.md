#SQLServer 

B 树解决了一个根本性问题：当磁盘访问速度比内存访问慢数千倍时，如何高效地查找磁盘上的数据。


### 磁盘上的二叉搜索树



内存中的二叉树
![[Pasted image 20251128085125.png|300]]

查找一个键需要 O(log₂ n) 次比较。
对于 100 万条记录，平衡二叉搜索树的高度为 log₂(1,000,000) ≈ 20。也就是说，需要进行 20 次比较才能找到任何一条记录。在内存中大约是0.002毫秒。

但这在磁盘上操作就是灾难；

==磁盘IO成本过高==
按照数据块的读取（4KB到16KB） **磁盘速度比内存慢 100 到 100,000 倍。**

==二叉树灾难==
  在磁盘上存储二叉搜索树时，每个节点都存储在单独的磁盘块中。从父节点遍历到子节点需要进行磁盘寻道。

针对 100 万条记录：

- 高度：20 个节点
- 磁盘寻道次数：20
- 硬盘读取时间：20 × 10 毫秒 = **200 毫秒**
- SSD 耗时：20 × 0.1 毫秒 = **2 毫秒**

对于固态硬盘来说，这尚可接受，但对于机械硬盘来说就太糟糕了。而且随着硬盘体积增大，情况还会更糟。

针对10亿条记录：
- 高度：30 个节点
- 硬盘读写时间：30 × 10 毫秒 = **300 毫秒**
- SSD 耗时：30 × 0.1 毫秒 = **3 毫秒**

**根本问题在于：** 二叉搜索树的扇出度太低（每个节点只有两个子节点）。我们需要增加每个节点的子节点数量来降低树的高度。


### 为什么不直接让树保持平衡呢？

你可能会想：“只要保持树木平衡就行了！”红黑树和AVL树就是这么做的。

问题不仅仅在于树的高度，还在于维护成本。平衡操作需要轮换节点和更新指针。在内存中，这很便宜（只需几次指针写入）。但在磁盘上，成本却很高：

1. 从磁盘读取节点（4 KB 数据块）
2. 修改内存中的节点
3. 将修改后的节点写回磁盘（4 KB 块）
4. 更新父指针（更多磁盘 I/O）

对于频繁插入和删除操作的树状数据结构，持续的重新平衡会严重影响性能。我们需要一种数据结构，它：

- 高扇出度（每个节点子节点数量多）→ 降低高度
- 需要不频繁的重新平衡 → 降低 I/O 开销

这种数据结构就是 B 树。

## 什么是B树？

B树是一种针对磁盘访问优化的自平衡树。与每个节点只有两个子节点（二叉树）不同，B树节点可以有**成百上千**个子节点。

**核心思想：** 每个 B 树节点都适合放在一个磁盘块中（4 KB 到 16 KB）。既然无论如何我们都必须读取整个磁盘块，那么就尽可能多地将键值打包到该磁盘块中。

### B树结构

B树节点存储：

- **N 个键**（已排序）
- **N + 1 个指向**子节点的指针

每个键都起到分隔符的作用：c​​hild[i] 中的键小于 key[i]，child[i+1] 中的键大于或等于 key[i]。

![[Pasted image 20251128091845.png|500]]

扇出约为 100 的 B 树。根节点有 2 个键和 3 个子节点。内部节点有 4 个键和 5 个子节点。叶节点包含实际数据。


### B树层次结构

B树有三种类型的节点：

**根节点：** 树的顶部。每个节点只有一个根节点。
**内部节点：** 用于指导搜索的中间层。它们存储分隔符键和指针，但不存储实际数据。
**叶节点：** 最底层，包含实际数据（键值对）。所有叶节点深度相同。

这是**B+树**，也是最常见的B树变体。B+树只在叶子节点存储数据，而B树也可以在内部节点存储数据。所有主流数据库都使用B+树，但为了简便起见，通常称之为“B树”。


### 为什么高扇出很重要

**二叉树（扇出=2）：**

- 100万条记录 → 高度 = 20
- 10亿条记录 → 高度 = 30

**B树（扇出=100）：**

- 100万条记录 → 高度 = 3（因为 100³ = 1,000,000）
- 10亿条记录 → 高度 = 5（因为 100⁵ = 10,000,000,000）

**B树（扇出=1000）：**

- 100万条记录 → 高度 = 2（因为 1000² = 1,000,000）
- 10亿条记录 → 高度 = 3（因为1000³ = 1,000,000,000）


![[Pasted image 20251128092050.png|500]]

**高扇出 = 更少的磁盘寻道次数 = 更快的查询速度。**


## B树查找算法

在 B 树中查找键值需要从根节点到叶节点进行遍历，并在每个节点进行二分查找。

**算法：**

1. 从根节点开始
2. 对当前节点中的键进行二分查找，以找到分隔符键范围。
3. 跟随相应的子指针
4. 重复此步骤直至到达叶节点。
5. 在叶子中，要么找到密钥，要么得出结论：密钥不存在。

**时间复杂度：**

- 树的高度：O(log_fanout n)
- 每个节点的二分查找复杂度：O(log₂扇出)
- 总计：O(log n)



## B树性能特征

### 查找复杂度

**时间复杂度：** O(log n)

对于具有 n 个键和 f 个扇出值的树：

- 树高：log_f(n)
- 每个节点的二分查找：log₂(f)
- 总比较次数：log_f(n) × log₂(f) = O(log n)

**磁盘 I/O：** log_f(n) 次磁盘读取（每层一次）

### 插入复杂度

**时间复杂度：** O(log n)

- 查找插入点的时间复杂度：O(log n)
- 插入到叶子节点：O(f) 到 Shift 键
- 必要时拆分：移动键的时间复杂度为 O(f)
- 分裂向上传播：最坏情况下会传播 O(log n) 个层级

**磁盘 I/O：** O(log n) 次磁盘读取 + O(log n) 次磁盘写入

### 删除复杂性

**时间复杂度：** O(log n)

- 查找密钥的时间复杂度：O(log n)
- 从叶子节点删除：O(f) 到 Shift 键
- 如有必要则合并：移动键的时间复杂度为 O(f)。
- 合并操作向上传播：最坏情况下需要 O(log n) 层。

**磁盘 I/O：** O(log n) 次磁盘读取 + O(log n) 次磁盘写入

### 空间复杂性

**空间复杂度：** O(n)

每个键只存储一次。内部节点会增加一些开销（指针和分隔符键），但这通常只占数据大小的 10-20%。

**占用率：** 节点通常占用 50-90%。更高的扇出可以提高空间效率，因为指针开销会相应减少。






参考：
[B-Trees: Why Every Database Uses Them - by Mehmet Gökçe](https://mehmetgoekce.substack.com/p/b-trees-why-every-database-uses-them)



# Spinlock 
https://www.sqlshack.com/sql-server-spinlocks/

自旋锁是用于保护数据的一种特殊形式的锁。自旋锁是SQLOS用来保护数据结构访问的**轻量级对象**


对于 SQLOS 来说，为每个共享数据结构使用 latch 器以同步多个线程对共享数据结构的访问是**过大**的。当一个线程试图在共享数据结构上获取一个latch时，另一个线程已经获取了一个不兼容的latch，该线程将不得不等待。它进入**挂起**状态并被移动到Waiter List中。线程会一直保持挂起状态，直到收到可以获取latch的信号，然后才会被移动到**Runnable Queue**等待 CPU 资源可用，并且它将一直留在那里，直到 CPU 可用于线程执行。一旦 CPU 可用，线程再次进入运行状态，它现在可以获取共享数据结构上的latch

可以看出，latch可能是一种同步高度活跃的数据结构的方式。**为了减少latch可能对繁忙的数据结构施加的开销**，SQL Server 已将**自旋锁**实现为同步对象的不同形式。虽然类似于闩锁，但有一个重要区别——自旋锁的等待是“活动的”，因为线程在等待时不会离开运行状态，这实际上意味着自旋锁==总是发生在 CPU 上==。

_不用马上移入到suspended状态，短期的进行spinlock判断，将更加省时_

当线程访问通常访问的数据结构的时间预计非常短时，SQLOS 使用自旋锁。如果试图获取自旋锁的线程无法访问目标数据结构，它会在运行状态下定期执行，即所谓的“自旋循环”以检查资源可用性，而不是立即让步到暂停状态。

自旋锁相对于latch的优势在于，获取 SQL Server 自旋锁的线程将在处于运行状态的 CPU 上循环执行，而尝试获取latch失败的线程将立即在挂起状态下屈服。这是一个代价高昂的操作，因为它需要切换一个线程的上下文以离开 CPU 以允许另一个线程进入运行状态，特别是对于在很短的时间内经常被占用的数据资源。相反，自旋锁在等待时会占用 CPU 周期，这可能会被其他线程使用


为了简单地解释 SQL Server 自旋锁背后的机制，让我们假设有一个经常使用的资源的请求，但使用的时间很短。由于这是在很短的时间内经常使用的资源，当一个线程试图访问该资源并且无法立即获得访问权限时，它将处于所谓的“冲突”状态。在这种情况下，如果线程等待的时间稍长一点，SQLOS 将假定资源可用的可能性很高。在这种情况下，SQLOS 假定资源变为可用所需的时间远短于线程自愿进入挂起状态并返回运行状态所需的时间。所以，线程将保持在运行状态，它会不断重复 SQLOS 的问题“我能获得 CPU 吗？……我能获得 CPU 吗？” 等等。在大多数情况下，CPU 应该会很快变得可用。线程必须在 CPU 上“旋转”的时间比预期长的情况，也将在文本的其余部分进行解释

SQL Server 正在使用许多不同的自旋锁，并且自旋锁的数量会随着每个新 SQL Server 版本的增加而增加。要检查自旋锁计数器，可以使用两个命令：

-   DBCC SQLPERF（SPINLOCKSTATS）
-  sys.dm_os_spinlock_stats
```sql
SELECT name, collisions, spins_per_collision
   FROM sys.dm_os_spinlock_stats
   ORDER BY spins_per_collision DESC;
```

-   **name**: the spinlock name
-   **collisions**: shows how many times a thread was blocked by a spinlock when attempting to access a protected resource
-   **spins**: shows how many times a thread loop spun while trying to acquire spinlock on resource
-   **spins_per_collision**: shows the spins/collisions ratio
-   **sleep_time**: shows the sleep time of a thread as a consequence of the backoff mechanism
-   **backoffs**: shows how many times the thread was backed off to grant CPU resource use to other threads













 [[SQL Server 中查询执行周期]]
#SQLServer/lock
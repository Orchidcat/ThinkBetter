/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// node_modules/validate-color/lib/index.js
var require_lib = __commonJS({
  "node_modules/validate-color/lib/index.js"(exports, module2) {
    module2.exports = function(e2) {
      var r2 = {};
      function t2(n2) {
        if (r2[n2])
          return r2[n2].exports;
        var a2 = r2[n2] = { i: n2, l: false, exports: {} };
        return e2[n2].call(a2.exports, a2, a2.exports, t2), a2.l = true, a2.exports;
      }
      return t2.m = e2, t2.c = r2, t2.d = function(e3, r3, n2) {
        t2.o(e3, r3) || Object.defineProperty(e3, r3, { enumerable: true, get: n2 });
      }, t2.r = function(e3) {
        "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e3, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(e3, "__esModule", { value: true });
      }, t2.t = function(e3, r3) {
        if (1 & r3 && (e3 = t2(e3)), 8 & r3)
          return e3;
        if (4 & r3 && "object" == typeof e3 && e3 && e3.__esModule)
          return e3;
        var n2 = /* @__PURE__ */ Object.create(null);
        if (t2.r(n2), Object.defineProperty(n2, "default", { enumerable: true, value: e3 }), 2 & r3 && "string" != typeof e3)
          for (var a2 in e3)
            t2.d(n2, a2, function(r4) {
              return e3[r4];
            }.bind(null, a2));
        return n2;
      }, t2.n = function(e3) {
        var r3 = e3 && e3.__esModule ? function() {
          return e3.default;
        } : function() {
          return e3;
        };
        return t2.d(r3, "a", r3), r3;
      }, t2.o = function(e3, r3) {
        return Object.prototype.hasOwnProperty.call(e3, r3);
      }, t2.p = "", t2(t2.s = 0);
    }([function(e2, r2, t2) {
      "use strict";
      t2.r(r2), t2.d(r2, "validateHTMLColorName", function() {
        return l2;
      }), t2.d(r2, "validateHTMLColorSpecialName", function() {
        return i2;
      }), t2.d(r2, "validateHTMLColorHex", function() {
        return u2;
      }), t2.d(r2, "validateHTMLColorRgb", function() {
        return g2;
      }), t2.d(r2, "validateHTMLColorHsl", function() {
        return y2;
      }), t2.d(r2, "validateHTMLColorHwb", function() {
        return L2;
      }), t2.d(r2, "validateHTMLColorLab", function() {
        return S2;
      }), t2.d(r2, "validateHTMLColorLch", function() {
        return m2;
      }), t2.d(r2, "validateHTMLColor", function() {
        return G2;
      });
      const n2 = (e3) => e3 && "string" == typeof e3, a2 = ["AliceBlue", "AntiqueWhite", "Aqua", "Aquamarine", "Azure", "Beige", "Bisque", "Black", "BlanchedAlmond", "Blue", "BlueViolet", "Brown", "BurlyWood", "CadetBlue", "Chartreuse", "Chocolate", "Coral", "CornflowerBlue", "Cornsilk", "Crimson", "Cyan", "DarkBlue", "DarkCyan", "DarkGoldenrod", "DarkGray", "DarkGrey", "DarkGreen", "DarkKhaki", "DarkMagenta", "DarkOliveGreen", "DarkOrange", "DarkOrchid", "DarkRed", "DarkSalmon", "DarkSeaGreen", "DarkSlateBlue", "DarkSlateGray", "DarkSlateGrey", "DarkTurquoise", "DarkViolet", "DeepPink", "DeepSkyBlue", "DimGray", "DimGrey", "DodgerBlue", "FireBrick", "FloralWhite", "ForestGreen", "Fuchsia", "Gainsboro", "GhostWhite", "Gold", "Goldenrod", "Gray", "Grey", "Green", "GreenYellow", "HoneyDew", "HotPink", "IndianRed", "Indigo", "Ivory", "Khaki", "Lavender", "LavenderBlush", "LawnGreen", "LemonChiffon", "LightBlue", "LightCoral", "LightCyan", "LightGoldenrodYellow", "LightGray", "LightGrey", "LightGreen", "LightPink", "LightSalmon", "LightSalmon", "LightSeaGreen", "LightSkyBlue", "LightSlateGray", "LightSlateGrey", "LightSteelBlue", "LightYellow", "Lime", "LimeGreen", "Linen", "Magenta", "Maroon", "MediumAquamarine", "MediumBlue", "MediumOrchid", "MediumPurple", "MediumSeaGreen", "MediumSlateBlue", "MediumSlateBlue", "MediumSpringGreen", "MediumTurquoise", "MediumVioletRed", "MidnightBlue", "MintCream", "MistyRose", "Moccasin", "NavajoWhite", "Navy", "OldLace", "Olive", "OliveDrab", "Orange", "OrangeRed", "Orchid", "PaleGoldenrod", "PaleGreen", "PaleTurquoise", "PaleVioletRed", "PapayaWhip", "PeachPuff", "Peru", "Pink", "Plum", "PowderBlue", "Purple", "RebeccaPurple", "Red", "RosyBrown", "RoyalBlue", "SaddleBrown", "Salmon", "SandyBrown", "SeaGreen", "SeaShell", "Sienna", "Silver", "SkyBlue", "SlateBlue", "SlateGray", "SlateGrey", "Snow", "SpringGreen", "SteelBlue", "Tan", "Teal", "Thistle", "Tomato", "Turquoise", "Violet", "Wheat", "White", "WhiteSmoke", "Yellow", "YellowGreen"], o2 = ["currentColor", "inherit", "transparent"], l2 = (e3) => {
        let r3 = false;
        return n2(e3) && a2.map((t3) => (e3.toLowerCase() === t3.toLowerCase() && (r3 = true), null)), r3;
      }, i2 = (e3) => {
        let r3 = false;
        return n2(e3) && o2.map((t3) => (e3.toLowerCase() === t3.toLowerCase() && (r3 = true), null)), r3;
      }, u2 = (e3) => {
        if (n2(e3)) {
          const r3 = /^#([\da-f]{3}){1,2}$|^#([\da-f]{4}){1,2}$/i;
          return e3 && r3.test(e3);
        }
        return false;
      }, d2 = "(([\\d]{0,5})((\\.([\\d]{1,5}))?))", s2 = `(${d2}%)`, c2 = "(([0-9]|[1-9][0-9]|100)%)", f2 = `(${c2}|(0?((\\.([\\d]{1,5}))?))|1)`, h2 = `([\\s]{0,5})\\)?)(([\\s]{0,5})(\\/?)([\\s]{1,5})${`(((${c2}))|(0?((\\.([\\d]{1,5}))?))|1))?`}([\\s]{0,5})\\)`, $2 = "(-?(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-9][0-9]|3[0-5][0-9])((\\.([\\d]{1,5}))?)|360)(deg)?)", g2 = (e3) => {
        if (n2(e3)) {
          const r3 = "([\\s]{0,5})([\\d]{1,5})%?([\\s]{0,5}),?", t3 = "((([\\s]{0,5}),?([\\s]{0,5}))|(([\\s]{1,5})))", n3 = new RegExp(`^(rgb)a?\\(${`${r3}${t3}`}${`${r3}${t3}`}${`${r3}${t3}`}(${"(\\/?([\\s]{0,5})(0?\\.?([\\d]{1,5})%?([\\s]{0,5}))?|1|0)"})?\\)$`);
          return e3 && n3.test(e3);
        }
        return false;
      }, y2 = (e3) => {
        if (n2(e3)) {
          const r3 = new RegExp(`^(hsl)a?\\((([\\s]{0,5})(${$2}|${"(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-9][0-9]|3[0-9][0-9]|400)grad)"}|${"((([0-5])?\\.([\\d]{1,5})|6\\.([0-9]|1[0-9]|2[0-8])|[0-6])rad)"}|${"((0?((\\.([\\d]{1,5}))?)|1)turn)"})((([\\s]{0,5}),([\\s]{0,5}))|(([\\s]{1,5}))))(([\\s]{0,5})(0|${c2})((([\\s]{0,5}),([\\s]{0,5}))|(([\\s]{1,5}))))(([\\s]{0,5})(0|${c2})([\\s]{0,5})\\)?)(([\\s]{0,5})(\\/?|,?)([\\s]{0,5})(((${c2}))|(0?((\\.([\\d]{1,5}))?))|1))?\\)$`);
          return e3 && r3.test(e3);
        }
        return false;
      }, L2 = (e3) => {
        if (n2(e3)) {
          const r3 = new RegExp(`^(hwb\\(([\\s]{0,5})${$2}([\\s]{1,5}))((0|${c2})([\\s]{1,5}))((0|${c2})${h2}$`);
          return e3 && r3.test(e3);
        }
        return false;
      }, S2 = (e3) => {
        if (n2(e3)) {
          const r3 = "(-?(([0-9]|[1-9][0-9]|1[0-5][0-9])((\\.([\\d]{1,5}))?)?|160))", t3 = new RegExp(`^(lab\\(([\\s]{0,5})${s2}([\\s]{1,5})${r3}([\\s]{1,5})${r3}${h2}$`);
          return e3 && t3.test(e3);
        }
        return false;
      }, m2 = (e3) => {
        if (n2(e3)) {
          const r3 = "((([0-9]|[1-9][0-9])?((\\.([\\d]{1,5}))?)|100)(%)?)", t3 = "" + d2, n3 = `((${$2})|(0|${f2})|(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-9][0-9]|3[0-5][0-9])((\\.([\\d]{1,5}))?)|360))`, a3 = `(\\/([\\s]{0,5})${f2})`, o3 = new RegExp(`^lch\\(${`(([\\s]{0,5})${r3}([\\s]{1,5})${t3}([\\s]{1,5})${n3}([\\s]{0,5})(${a3})?)`}\\)$`);
          return e3 && o3.test(e3);
        }
        return false;
      }, G2 = (e3) => !!(e3 && u2(e3) || g2(e3) || y2(e3) || L2(e3) || S2(e3) || m2(e3));
      r2.default = (e3) => !!(e3 && u2(e3) || l2(e3) || i2(e3) || g2(e3) || y2(e3) || L2(e3) || S2(e3) || m2(e3));
    }]);
  }
});

// node_modules/quantize/quantize.js
var require_quantize = __commonJS({
  "node_modules/quantize/quantize.js"(exports, module2) {
    if (!pv) {
      pv = {
        map: function(array, f2) {
          var o2 = {};
          return f2 ? array.map(function(d2, i2) {
            o2.index = i2;
            return f2.call(o2, d2);
          }) : array.slice();
        },
        naturalOrder: function(a2, b2) {
          return a2 < b2 ? -1 : a2 > b2 ? 1 : 0;
        },
        sum: function(array, f2) {
          var o2 = {};
          return array.reduce(f2 ? function(p2, d2, i2) {
            o2.index = i2;
            return p2 + f2.call(o2, d2);
          } : function(p2, d2) {
            return p2 + d2;
          }, 0);
        },
        max: function(array, f2) {
          return Math.max.apply(null, f2 ? pv.map(array, f2) : array);
        }
      };
    }
    var pv;
    var MMCQ = function() {
      var sigbits = 5, rshift = 8 - sigbits, maxIterations = 1e3, fractByPopulations = 0.75;
      function getColorIndex(r2, g2, b2) {
        return (r2 << 2 * sigbits) + (g2 << sigbits) + b2;
      }
      function PQueue(comparator) {
        var contents = [], sorted = false;
        function sort() {
          contents.sort(comparator);
          sorted = true;
        }
        return {
          push: function(o2) {
            contents.push(o2);
            sorted = false;
          },
          peek: function(index) {
            if (!sorted)
              sort();
            if (index === void 0)
              index = contents.length - 1;
            return contents[index];
          },
          pop: function() {
            if (!sorted)
              sort();
            return contents.pop();
          },
          size: function() {
            return contents.length;
          },
          map: function(f2) {
            return contents.map(f2);
          },
          debug: function() {
            if (!sorted)
              sort();
            return contents;
          }
        };
      }
      function VBox(r1, r2, g1, g2, b1, b2, histo) {
        var vbox = this;
        vbox.r1 = r1;
        vbox.r2 = r2;
        vbox.g1 = g1;
        vbox.g2 = g2;
        vbox.b1 = b1;
        vbox.b2 = b2;
        vbox.histo = histo;
      }
      VBox.prototype = {
        volume: function(force) {
          var vbox = this;
          if (!vbox._volume || force) {
            vbox._volume = (vbox.r2 - vbox.r1 + 1) * (vbox.g2 - vbox.g1 + 1) * (vbox.b2 - vbox.b1 + 1);
          }
          return vbox._volume;
        },
        count: function(force) {
          var vbox = this, histo = vbox.histo;
          if (!vbox._count_set || force) {
            var npix = 0, i2, j2, k2, index;
            for (i2 = vbox.r1; i2 <= vbox.r2; i2++) {
              for (j2 = vbox.g1; j2 <= vbox.g2; j2++) {
                for (k2 = vbox.b1; k2 <= vbox.b2; k2++) {
                  index = getColorIndex(i2, j2, k2);
                  npix += histo[index] || 0;
                }
              }
            }
            vbox._count = npix;
            vbox._count_set = true;
          }
          return vbox._count;
        },
        copy: function() {
          var vbox = this;
          return new VBox(vbox.r1, vbox.r2, vbox.g1, vbox.g2, vbox.b1, vbox.b2, vbox.histo);
        },
        avg: function(force) {
          var vbox = this, histo = vbox.histo;
          if (!vbox._avg || force) {
            var ntot = 0, mult = 1 << 8 - sigbits, rsum = 0, gsum = 0, bsum = 0, hval, i2, j2, k2, histoindex;
            for (i2 = vbox.r1; i2 <= vbox.r2; i2++) {
              for (j2 = vbox.g1; j2 <= vbox.g2; j2++) {
                for (k2 = vbox.b1; k2 <= vbox.b2; k2++) {
                  histoindex = getColorIndex(i2, j2, k2);
                  hval = histo[histoindex] || 0;
                  ntot += hval;
                  rsum += hval * (i2 + 0.5) * mult;
                  gsum += hval * (j2 + 0.5) * mult;
                  bsum += hval * (k2 + 0.5) * mult;
                }
              }
            }
            if (ntot) {
              vbox._avg = [~~(rsum / ntot), ~~(gsum / ntot), ~~(bsum / ntot)];
            } else {
              vbox._avg = [~~(mult * (vbox.r1 + vbox.r2 + 1) / 2), ~~(mult * (vbox.g1 + vbox.g2 + 1) / 2), ~~(mult * (vbox.b1 + vbox.b2 + 1) / 2)];
            }
          }
          return vbox._avg;
        },
        contains: function(pixel) {
          var vbox = this, rval = pixel[0] >> rshift;
          gval = pixel[1] >> rshift;
          bval = pixel[2] >> rshift;
          return rval >= vbox.r1 && rval <= vbox.r2 && gval >= vbox.g1 && gval <= vbox.g2 && bval >= vbox.b1 && bval <= vbox.b2;
        }
      };
      function CMap() {
        this.vboxes = new PQueue(function(a2, b2) {
          return pv.naturalOrder(
            a2.vbox.count() * a2.vbox.volume(),
            b2.vbox.count() * b2.vbox.volume()
          );
        });
        ;
      }
      CMap.prototype = {
        push: function(vbox) {
          this.vboxes.push({
            vbox,
            color: vbox.avg()
          });
        },
        palette: function() {
          return this.vboxes.map(function(vb) {
            return vb.color;
          });
        },
        size: function() {
          return this.vboxes.size();
        },
        map: function(color) {
          var vboxes = this.vboxes;
          for (var i2 = 0; i2 < vboxes.size(); i2++) {
            if (vboxes.peek(i2).vbox.contains(color)) {
              return vboxes.peek(i2).color;
            }
          }
          return this.nearest(color);
        },
        nearest: function(color) {
          var vboxes = this.vboxes, d1, d2, pColor;
          for (var i2 = 0; i2 < vboxes.size(); i2++) {
            d2 = Math.sqrt(
              Math.pow(color[0] - vboxes.peek(i2).color[0], 2) + Math.pow(color[1] - vboxes.peek(i2).color[1], 2) + Math.pow(color[2] - vboxes.peek(i2).color[2], 2)
            );
            if (d2 < d1 || d1 === void 0) {
              d1 = d2;
              pColor = vboxes.peek(i2).color;
            }
          }
          return pColor;
        },
        forcebw: function() {
          var vboxes = this.vboxes;
          vboxes.sort(function(a2, b2) {
            return pv.naturalOrder(pv.sum(a2.color), pv.sum(b2.color));
          });
          var lowest = vboxes[0].color;
          if (lowest[0] < 5 && lowest[1] < 5 && lowest[2] < 5)
            vboxes[0].color = [0, 0, 0];
          var idx = vboxes.length - 1, highest = vboxes[idx].color;
          if (highest[0] > 251 && highest[1] > 251 && highest[2] > 251)
            vboxes[idx].color = [255, 255, 255];
        }
      };
      function getHisto(pixels) {
        var histosize = 1 << 3 * sigbits, histo = new Array(histosize), index, rval, gval2, bval2;
        pixels.forEach(function(pixel) {
          rval = pixel[0] >> rshift;
          gval2 = pixel[1] >> rshift;
          bval2 = pixel[2] >> rshift;
          index = getColorIndex(rval, gval2, bval2);
          histo[index] = (histo[index] || 0) + 1;
        });
        return histo;
      }
      function vboxFromPixels(pixels, histo) {
        var rmin = 1e6, rmax = 0, gmin = 1e6, gmax = 0, bmin = 1e6, bmax = 0, rval, gval2, bval2;
        pixels.forEach(function(pixel) {
          rval = pixel[0] >> rshift;
          gval2 = pixel[1] >> rshift;
          bval2 = pixel[2] >> rshift;
          if (rval < rmin)
            rmin = rval;
          else if (rval > rmax)
            rmax = rval;
          if (gval2 < gmin)
            gmin = gval2;
          else if (gval2 > gmax)
            gmax = gval2;
          if (bval2 < bmin)
            bmin = bval2;
          else if (bval2 > bmax)
            bmax = bval2;
        });
        return new VBox(rmin, rmax, gmin, gmax, bmin, bmax, histo);
      }
      function medianCutApply(histo, vbox) {
        if (!vbox.count())
          return;
        var rw = vbox.r2 - vbox.r1 + 1, gw = vbox.g2 - vbox.g1 + 1, bw = vbox.b2 - vbox.b1 + 1, maxw = pv.max([rw, gw, bw]);
        if (vbox.count() == 1) {
          return [vbox.copy()];
        }
        var total = 0, partialsum = [], lookaheadsum = [], i2, j2, k2, sum, index;
        if (maxw == rw) {
          for (i2 = vbox.r1; i2 <= vbox.r2; i2++) {
            sum = 0;
            for (j2 = vbox.g1; j2 <= vbox.g2; j2++) {
              for (k2 = vbox.b1; k2 <= vbox.b2; k2++) {
                index = getColorIndex(i2, j2, k2);
                sum += histo[index] || 0;
              }
            }
            total += sum;
            partialsum[i2] = total;
          }
        } else if (maxw == gw) {
          for (i2 = vbox.g1; i2 <= vbox.g2; i2++) {
            sum = 0;
            for (j2 = vbox.r1; j2 <= vbox.r2; j2++) {
              for (k2 = vbox.b1; k2 <= vbox.b2; k2++) {
                index = getColorIndex(j2, i2, k2);
                sum += histo[index] || 0;
              }
            }
            total += sum;
            partialsum[i2] = total;
          }
        } else {
          for (i2 = vbox.b1; i2 <= vbox.b2; i2++) {
            sum = 0;
            for (j2 = vbox.r1; j2 <= vbox.r2; j2++) {
              for (k2 = vbox.g1; k2 <= vbox.g2; k2++) {
                index = getColorIndex(j2, k2, i2);
                sum += histo[index] || 0;
              }
            }
            total += sum;
            partialsum[i2] = total;
          }
        }
        partialsum.forEach(function(d2, i3) {
          lookaheadsum[i3] = total - d2;
        });
        function doCut(color) {
          var dim1 = color + "1", dim2 = color + "2", left, right, vbox1, vbox2, d2, count2 = 0;
          for (i2 = vbox[dim1]; i2 <= vbox[dim2]; i2++) {
            if (partialsum[i2] > total / 2) {
              vbox1 = vbox.copy();
              vbox2 = vbox.copy();
              left = i2 - vbox[dim1];
              right = vbox[dim2] - i2;
              if (left <= right)
                d2 = Math.min(vbox[dim2] - 1, ~~(i2 + right / 2));
              else
                d2 = Math.max(vbox[dim1], ~~(i2 - 1 - left / 2));
              while (!partialsum[d2])
                d2++;
              count2 = lookaheadsum[d2];
              while (!count2 && partialsum[d2 - 1])
                count2 = lookaheadsum[--d2];
              vbox1[dim2] = d2;
              vbox2[dim1] = vbox1[dim2] + 1;
              return [vbox1, vbox2];
            }
          }
        }
        return maxw == rw ? doCut("r") : maxw == gw ? doCut("g") : doCut("b");
      }
      function quantize2(pixels, maxcolors) {
        if (!pixels.length || maxcolors < 2 || maxcolors > 256) {
          return false;
        }
        var histo = getHisto(pixels), histosize = 1 << 3 * sigbits;
        var nColors = 0;
        histo.forEach(function() {
          nColors++;
        });
        if (nColors <= maxcolors) {
        }
        var vbox = vboxFromPixels(pixels, histo), pq = new PQueue(function(a2, b2) {
          return pv.naturalOrder(a2.count(), b2.count());
        });
        pq.push(vbox);
        function iter(lh, target) {
          var ncolors = 1, niters = 0, vbox2;
          while (niters < maxIterations) {
            vbox2 = lh.pop();
            if (!vbox2.count()) {
              lh.push(vbox2);
              niters++;
              continue;
            }
            var vboxes = medianCutApply(histo, vbox2), vbox1 = vboxes[0], vbox22 = vboxes[1];
            if (!vbox1) {
              return;
            }
            lh.push(vbox1);
            if (vbox22) {
              lh.push(vbox22);
              ncolors++;
            }
            if (ncolors >= target)
              return;
            if (niters++ > maxIterations) {
              return;
            }
          }
        }
        iter(pq, fractByPopulations * maxcolors);
        var pq2 = new PQueue(function(a2, b2) {
          return pv.naturalOrder(a2.count() * a2.volume(), b2.count() * b2.volume());
        });
        while (pq.size()) {
          pq2.push(pq.pop());
        }
        iter(pq2, maxcolors - pq2.size());
        var cmap = new CMap();
        while (pq2.size()) {
          cmap.push(pq2.pop());
        }
        return cmap;
      }
      return {
        quantize: quantize2
      };
    }();
    module2.exports = MMCQ.quantize;
  }
});

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => ColorPalette2,
  urlRegex: () => urlRegex
});
module.exports = __toCommonJS(main_exports);
var import_obsidian10 = require("obsidian");

// src/components/EditorModal.ts
var import_obsidian5 = require("obsidian");

// src/components/Palette.ts
var import_obsidian4 = require("obsidian");

// src/settings.ts
var import_obsidian2 = require("obsidian");

// src/utils/basicUtils.ts
var import_obsidian = require("obsidian");
function getModifiedSettings(settings) {
  let newSettings = {};
  for (const [key, value] of Object.entries(settings)) {
    const defaultVal = defaultSettings[key];
    if (key in defaultSettings) {
      if (value !== defaultVal)
        newSettings = { ...newSettings, [key]: value };
    } else {
      if (value instanceof Array && value.length === 0)
        break;
      else
        newSettings = { ...newSettings, [key]: value };
    }
  }
  return Object.keys(newSettings).length !== 0 ? newSettings : void 0;
}
function parseUrl(url) {
  var _a;
  if (url.includes("-")) {
    return url.substring(url.lastIndexOf("/") + 1).split("-").map((i2) => "#" + i2);
  } else
    return ((_a = url.substring(url.lastIndexOf("/") + 1).match(/.{1,6}/g)) == null ? void 0 : _a.map((i2) => "#" + i2)) || [];
}
function pluginToPaletteSettings(pluginSettings) {
  return {
    height: pluginSettings.height,
    width: pluginSettings.width,
    direction: pluginSettings.direction,
    gradient: pluginSettings.gradient,
    hover: pluginSettings.hover,
    hideText: pluginSettings.hideText,
    override: pluginSettings.override,
    aliases: []
  };
}
function createPaletteBlock(input) {
  if (typeof input === "string")
    return `\`\`\`palette
${input}
\`\`\`
`;
  else
    return input.settings ? `\`\`\`palette
${toNString(input.colors)}
${JSON.stringify(input.settings)}
\`\`\`
` : `\`\`\`palette
${toNString(input.colors)}
\`\`\`
`;
}
function getForegroundColor(color) {
  return color.rgb()[0] * 0.299 + color.rgb()[1] * 0.587 + color.rgb()[2] * 0.114 > 186 ? "#000000" : "#ffffff";
}
function toNString(array) {
  let result = "";
  for (const string of array) {
    result += string + "\n";
  }
  return result.trim();
}
async function copyToClipboard(text, copyFormat) {
  let copiedText = text;
  if (copyFormat === "Value" /* Value */ && !text.includes("`")) {
    if (copiedText.includes("#"))
      copiedText = copiedText.split("#")[1];
    else if (copiedText.includes("("))
      copiedText = copiedText.split("(")[1].split(")")[0];
  }
  new import_obsidian.Notice(`Copied ${copiedText}`);
  await navigator.clipboard.writeText(copiedText);
}

// src/settings.ts
var defaultSettings = {
  noticeDuration: 1e4,
  errorPulse: true,
  aliasMode: "Both" /* Both */,
  corners: true,
  stabilityWhileEditing: true,
  reloadDelay: 5,
  copyFormat: "Raw" /* Raw */,
  height: 150,
  width: 700,
  direction: "column" /* Column */,
  gradient: false,
  hover: true,
  hideText: false,
  override: false
};
var SettingsTab = class extends import_obsidian2.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    let { settings } = this.plugin;
    this.settings = pluginToPaletteSettings(settings);
    this.reloadDelay = settings.reloadDelay;
    containerEl.empty();
    containerEl.createEl("h2").setText("General");
    containerEl.addClass("color-palette-settings");
    new import_obsidian2.Setting(containerEl).setName("Alias Mode").setDesc("What will be shown when aliases option is set in local palette options. Defaults to showing both color and alias.").addDropdown((dropdown) => {
      dropdown.addOption("Both" /* Both */, "Both" /* Both */).addOption("Prefer Alias" /* Alias */, "Prefer Alias" /* Alias */).setValue(this.plugin.settings.aliasMode).onChange(async (value) => {
        settings.aliasMode = value;
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian2.Setting(containerEl).setName("Palette Corners").setDesc("Minor aesthetic change which toggles whether the corners on palettes are rounded.").addToggle((toggle) => {
      toggle.setValue(settings.corners).onChange(async (value) => {
        settings.corners = value;
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian2.Setting(containerEl).setName("Stability While Editing").setDesc("Keeps the palette from moving while in edit mode.").addToggle((toggle) => {
      toggle.setValue(settings.stabilityWhileEditing).onChange(async (value) => {
        settings.stabilityWhileEditing = value;
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian2.Setting(containerEl).setName("Reload Delay").setDesc("How long it takes in milliseconds for palettes to be updated after changes have been made (Larger values are less responsive).").addText((text) => {
      text.setValue(settings.reloadDelay.toString()).onChange(async (value) => {
        try {
          if (!Number.isNaN(Number(value))) {
            settings.reloadDelay = Number(value);
            await this.plugin.saveSettings();
          } else
            throw new Error("Please enter a number.");
        } catch (e2) {
          new import_obsidian2.Notice(e2);
        }
      });
    });
    new import_obsidian2.Setting(containerEl).setName("Copy Format").setDesc("Choice of format when copying colors.").addDropdown((dropdown) => {
      dropdown.addOption("Raw" /* Raw */, "Raw" /* Raw */).addOption("Value" /* Value */, "Value" /* Value */).setValue(this.plugin.settings.copyFormat).onChange(async (value) => {
        settings.copyFormat = value;
        await this.plugin.saveSettings();
      });
    });
    containerEl.createEl("h2").setText("Defaults");
    new import_obsidian2.Setting(containerEl).setName("Height").addText((text) => {
      text.setValue(settings.height.toString()).onChange(async (value) => {
        try {
          if (!Number.isNaN(Number(value))) {
            settings.height = Number(value);
            await this.plugin.saveSettings();
          } else
            throw new Error("Please enter a number.");
        } catch (e2) {
          new import_obsidian2.Notice(e2);
        }
      });
    });
    new import_obsidian2.Setting(containerEl).setName("Width").setDesc("Caution - Might cause palettes to display incorrectly.").addText((text) => {
      text.setValue(settings.width.toString()).onChange(async (value) => {
        try {
          if (!Number.isNaN(Number(value))) {
            settings.width = Number(value);
            await this.plugin.saveSettings();
          } else
            throw new Error("Please enter a number.");
        } catch (e2) {
          new import_obsidian2.Notice(e2);
        }
      });
    });
    new import_obsidian2.Setting(containerEl).setName("Direction").addDropdown((dropdown) => {
      dropdown.addOption("column" /* Column */, "column" /* Column */).addOption("row" /* Row */, "row" /* Row */).setValue(this.plugin.settings.direction).onChange(async (value) => {
        settings.direction = value;
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian2.Setting(containerEl).setName("Gradient").addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.gradient).onChange(async (value) => {
        settings.gradient = value;
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian2.Setting(containerEl).setName("Hover").setDesc("Toggles whether palettes can be hovered").addToggle((toggle) => {
      toggle.setValue(settings.hover).onChange(async (value) => {
        settings.hover = value;
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian2.Setting(containerEl).setName("Hide Text").setDesc("Disables color and alias visibility").addToggle((toggle) => {
      toggle.setValue(settings.hideText).onChange(async (value) => {
        settings.hideText = value;
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian2.Setting(containerEl).setName("Override").setDesc("Disables color validation for full control (advanced)").addToggle((toggle) => {
      toggle.setValue(settings.override).onChange(async (value) => {
        settings.override = value;
        await this.plugin.saveSettings();
      });
    });
    containerEl.createEl("h2").setText("Other");
    new import_obsidian2.Setting(containerEl).setName("Palette Error Pulse").setDesc("Whether the affected palette should pulse when encountering an error.").addToggle((toggle) => {
      toggle.setValue(settings.errorPulse).onChange(async (value) => {
        settings.errorPulse = value;
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian2.Setting(containerEl).setName("Notice Duration").setDesc("How long palette error messages are show for in seconds (0 for indefinite).").addText((text) => {
      text.setValue((settings.noticeDuration / 1e3).toString()).onChange(async (value) => {
        try {
          if (!Number.isNaN(Number(value))) {
            settings.noticeDuration = Number(value) * 1e3;
            await this.plugin.saveSettings();
          } else
            throw new Error("Please enter a number.");
        } catch (e2) {
          new import_obsidian2.Notice(e2);
        }
      });
    });
    new import_obsidian2.Setting(containerEl).setName("Donate").setDesc("If you like this plugin, consider donating to support continued development.").addButton((button) => {
      button.onClick(() => open("https://github.com/sponsors/ALegendsTale")).setClass("color-palette-donate");
      const image = button.buttonEl.appendChild(createEl("img"));
      image.src = "https://img.shields.io/badge/Sponsor-%E2%9D%A4-%23EA4AAA?style=flat&logo=Github";
    }).addButton((button) => {
      button.onClick(() => open("https://www.paypal.com/donate/?hosted_button_id=BHHFMGX822K4S")).setClass("color-palette-donate");
      const image = button.buttonEl.appendChild(createEl("img"));
      image.src = "https://img.shields.io/badge/Paypal-%23003087?style=flat&logo=Paypal";
    });
  }
  // Called when settings are exited
  hide() {
    var _a;
    const settingsChanged = JSON.stringify(this.settings) !== JSON.stringify(pluginToPaletteSettings(this.plugin.settings));
    const reloadDelayChanged = this.reloadDelay !== this.plugin.settings.reloadDelay;
    if (((_a = this.plugin) == null ? void 0 : _a.palettes) && (settingsChanged || reloadDelayChanged)) {
      for (let paletteMRC of this.plugin.palettes) {
        paletteMRC.update();
      }
    }
  }
};

// node_modules/colorsea/dist/index.esm.js
function t(t2, r2, n2, e2) {
  var o2, i2 = arguments.length, a2 = i2 < 3 ? r2 : null === e2 ? e2 = Object.getOwnPropertyDescriptor(r2, n2) : e2;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
    a2 = Reflect.decorate(t2, r2, n2, e2);
  else
    for (var u2 = t2.length - 1; u2 >= 0; u2--)
      (o2 = t2[u2]) && (a2 = (i2 < 3 ? o2(a2) : i2 > 3 ? o2(r2, n2, a2) : o2(r2, n2)) || a2);
  return i2 > 3 && a2 && Object.defineProperty(r2, n2, a2), a2;
}
function r(t2, r2, n2) {
  if (n2 || 2 === arguments.length)
    for (var e2, o2 = 0, i2 = r2.length; o2 < i2; o2++)
      !e2 && o2 in r2 || (e2 || (e2 = Array.prototype.slice.call(r2, 0, o2)), e2[o2] = r2[o2]);
  return t2.concat(e2 || Array.prototype.slice.call(r2));
}
var n = function(t2, r2, n2) {
  return [t2, r2, n2].map(function(t3) {
    return (t3 /= 255) > 0.04045 ? Math.pow((t3 + 0.055) / 1.055, 2.4) : t3 / 12.92;
  });
};
var e = function(t2, r2, n2) {
  return [t2, r2, n2].map(function(t3) {
    return 255 * (t3 <= 304e-5 ? 12.92 * t3 : 1.055 * Math.pow(t3, 1 / 2.4) - 0.055);
  });
};
var o = function(t2, r2, n2) {
  return Math.min(Math.max(t2, r2), n2);
};
var i = function(t2, r2) {
  return Math.round((t2 + Number.EPSILON) * Math.pow(10, r2)) / Math.pow(10, r2);
};
var a = function(t2, r2) {
  return Math.floor(Math.random() * (r2 - t2 + 1) - t2);
};
var u = function(t2, r2, n2, e2) {
  for (var i2, a2 = [t2, r2, n2], u2 = "#", h2 = 0; h2 < a2.length; h2++)
    u2 += (i2 = a2[h2], Math.round(o(i2, 0, 255)).toString(16).padStart(2, "0"));
  return null != e2 && (u2 += Math.round(o(e2, 0, 100) / 100 * 255).toString(16).padStart(2, "0")), u2;
};
var h = function(t2) {
  var n2 = t2.length, e2 = (t2 = function(t3) {
    var r2 = (t3 = /^#/.test(t3) ? t3.slice(1) : t3).length;
    if (![3, 4, 6, 8].includes(r2))
      return "000000";
    if (6 === r2 || 8 === r2)
      return t3;
    if (3 === r2 || 4 === r2) {
      for (var n3 = "", e3 = 0; e3 < r2; e3++) {
        var o3 = t3[e3];
        n3 += "" + o3 + o3;
      }
      return n3;
    }
    return "000000";
  }(t2).padEnd(8, "ff")).match(/.{2}/g);
  if (!e2)
    return [0, 0, 0, 1];
  var o2 = [0, 0, 0], i2 = false;
  return e2.forEach(function(t3, r2) {
    r2 < 3 ? o2[r2] = parseInt(t3, 16) : i2 = 100 * parseInt(t3, 16) / 255;
  }), false === i2 || n2 < 8 ? o2 : r(r([], o2, true), [i2], false);
};
var c = function(t2, r2, n2) {
  var e2;
  e2 = [t2, r2, n2].map(function(t3) {
    return t3 / 255;
  }), t2 = e2[0], r2 = e2[1], n2 = e2[2];
  var o2 = 1 - Math.max(t2, r2, n2), i2 = o2 < 1 ? 1 / (1 - o2) : 0;
  return [(1 - t2 - o2) * i2 * 100, (1 - r2 - o2) * i2 * 100, (1 - n2 - o2) * i2 * 100, 100 * o2];
};
var l = function(t2, r2, n2, e2) {
  return 100 === e2 ? [0, 0, 0] : (e2 /= 100, [t2, r2, n2].map(function(t3) {
    return (t3 /= 100) >= 1 ? 0 : 255 * (1 - t3) * (1 - e2);
  }));
};
function p(t2, r2, n2, e2) {
  var o2;
  void 0 === e2 && (e2 = "l"), o2 = [t2, r2, n2].map(function(t3) {
    return t3 / 255;
  }), t2 = o2[0], r2 = o2[1], n2 = o2[2];
  var i2 = Math.max(t2, r2, n2), a2 = Math.min(t2, r2, n2), u2 = function(t3, r3, n3, e3) {
    var o3;
    void 0 === e3 && (e3 = false), o3 = [t3, r3, n3].map(function(t4) {
      return t4 / 255;
    }), t3 = o3[0], r3 = o3[1], n3 = o3[2];
    var i3 = Math.max(t3, r3, n3), a3 = Math.min(t3, r3, n3), u3 = 0;
    if (i3 !== a3)
      if (e3)
        u3 = (t3 - r3 + (t3 - n3)) / 2, u3 /= Math.sqrt((t3 - r3) * (t3 - r3) + (t3 - n3) * (r3 - n3)), u3 = Math.acos(u3), n3 > r3 && (u3 = 2 * Math.PI - u3), u3 /= 2 * Math.PI;
      else {
        var h3 = i3 - a3;
        u3 = i3 === t3 ? (r3 - n3) / h3 + (r3 < n3 ? 6 : 0) : i3 === r3 ? (n3 - t3) / h3 + 2 : (t3 - r3) / h3 + 4, u3 /= 6;
      }
    else
      u3 = NaN;
    return 360 * u3;
  }(t2, r2, n2, "i" === e2), h2 = 0, c2 = (i2 + a2) / 2, l2 = i2 - a2, p2 = i2, f2 = (t2 + r2 + n2) / 3;
  return "v" === e2 && (h2 = 0 === i2 ? 0 : l2 / i2), i2 !== a2 && "l" === e2 && (h2 = c2 > 0.5 ? l2 / (2 - i2 - a2) : l2 / (i2 + a2)), "i" === e2 && (h2 = f2 > 0 ? 1 - a2 / f2 : 0), h2 *= 100, c2 *= 100, f2 *= 100, "l" === e2 ? [u2, h2, c2] : "v" === e2 ? [u2, h2, p2 *= 100] : [u2, h2, f2];
}
var f = function(t2, r2, n2) {
  return p(t2, r2, n2, "l");
};
var s = function(t2, r2, n2) {
  var e2, i2, a2 = function(t3) {
    return 6 * (t3 = t3 < 0 ? t3 + 1 : t3 > 1 ? t3 - 1 : t3) < 1 ? e2 + (i2 - e2) * t3 * 6 : 2 * t3 < 1 ? i2 : 3 * t3 < 2 ? e2 + (i2 - e2) * (2 / 3 - t3) * 6 : e2;
  };
  return t2 = t2 % 360 / 360, r2 = o(r2 / 100, 0, 1), n2 = o(n2 / 100, 0, 1), e2 = 2 * n2 - (i2 = n2 <= 0.5 ? n2 * (r2 + 1) : n2 + r2 - n2 * r2), [255 * a2(t2 + 1 / 3), 255 * a2(t2), 255 * a2(t2 - 1 / 3)];
};
var v = function(t2, r2, n2) {
  return p(t2, r2, n2, "v");
};
var b = function(t2, r2, n2) {
  var e2, o2, i2 = [n2 /= 100, n2 * (1 - (r2 /= 100)), n2 * (1 - (o2 = (t2 = t2 % 360 / 360 * 360) / 60 - (e2 = Math.floor(t2 / 60 % 6))) * r2), n2 * (1 - (1 - o2) * r2)], a2 = [[0, 3, 1], [2, 0, 1], [1, 0, 3], [1, 2, 0], [3, 1, 0], [0, 1, 2]];
  return [255 * i2[a2[e2][0]], 255 * i2[a2[e2][1]], 255 * i2[a2[e2][2]]];
};
var y = function(t2, r2, n2) {
  return p(t2, r2, n2, "i");
};
var d = function(t2, r2, n2) {
  var e2, i2, a2, u2;
  r2 /= 100, n2 /= 100, isNaN(t2) && (t2 = 0), isNaN(r2) && (r2 = 0);
  var h2 = function(t3) {
    return (1 + r2 * Math.cos(2 * Math.PI * t3) / Math.cos(Math.PI / 3 - 2 * Math.PI * t3)) / 3;
  };
  return (t2 = (360 + t2) % 360 / 360) < 1 / 3 ? a2 = 1 - ((u2 = (1 - r2) / 3) + (i2 = h2(t2))) : t2 < 2 / 3 ? u2 = 1 - ((i2 = (1 - r2) / 3) + (a2 = h2(t2 -= 1 / 3))) : i2 = 1 - ((a2 = (1 - r2) / 3) + (u2 = h2(t2 -= 2 / 3))), e2 = [i2, a2, u2].map(function(t3) {
    return 255 * o(n2 * t3 * 3, 0, 1);
  }), [i2 = e2[0], a2 = e2[1], u2 = e2[2]];
};
var g = function(t2, r2, n2) {
  return [f(t2, r2, n2)[0], 100 * (Math.min(t2, r2, n2) / 255), 100 * (1 - Math.max(t2, r2, n2) / 255)];
};
function w(t2, r2, n2) {
  return r2 /= 100, n2 /= 100, s(t2, 100, 50).map(function(t3) {
    return 255 * (t3 / 255 * (1 - r2 - n2) + r2);
  });
}
var m = { x: [0.4124564, 0.3575761, 0.1804375], y: [0.2126729, 0.7151522, 0.072175], z: [0.0193339, 0.119192, 0.9503041] };
var M = { r: [3.2404542, -1.5371385, -0.4985314], g: [-0.969266, 1.8760108, 0.041556], b: [0.0556434, -0.2040259, 1.0572252] };
var x = 0.95047;
var _ = 1;
var C = 1.08883;
var I = 0.206896552;
var k = 8856452e-9;
var E = 24389 / 27;
var z = function(t2, r2, e2) {
  var o2 = n(t2, r2, e2);
  return [100 * m.x.reduce(function(t3, r3, n2) {
    return t3 + r3 * o2[n2];
  }, 0), 100 * m.y.reduce(function(t3, r3, n2) {
    return t3 + r3 * o2[n2];
  }, 0), 100 * m.z.reduce(function(t3, r3, n2) {
    return t3 + r3 * o2[n2];
  }, 0)];
};
var N = function(t2, r2, n2) {
  var o2 = [t2, r2, n2], i2 = M.r.reduce(function(t3, r3, n3) {
    return t3 + r3 * o2[n3];
  }, 0) / 100, a2 = M.g.reduce(function(t3, r3, n3) {
    return t3 + r3 * o2[n3];
  }, 0) / 100, u2 = M.b.reduce(function(t3, r3, n3) {
    return t3 + r3 * o2[n3];
  }, 0) / 100;
  return e(i2, a2, u2);
};
var O = function(t2, r2, n2) {
  var e2;
  return e2 = [t2 = t2 / x / 100, r2 = r2 / _ / 100, n2 = n2 / C / 100].map(function(t3) {
    return t3 > k ? Math.pow(t3, 1 / 3) : (E * t3 + 16) / 116;
  }), t2 = e2[0], r2 = e2[1], n2 = e2[2], [Math.max(0, 116 * r2 - 16), 500 * (t2 - r2), 200 * (r2 - n2)];
};
var P = function(t2, r2, n2) {
  var e2, o2 = (t2 + 16) / 116, i2 = isNaN(r2) ? o2 : o2 + r2 / 500, a2 = isNaN(n2) ? o2 : o2 - n2 / 200;
  return e2 = [i2, o2, a2].map(function(t3) {
    return t3 > I ? Math.pow(t3, 3) : (116 * t3 - 16) / E;
  }), i2 = e2[0], o2 = e2[1], a2 = e2[2], [i2 * x * 100, o2 * _ * 100, a2 * C * 100];
};
var j = function(t2, r2, n2) {
  return N.apply(void 0, P(t2, r2, n2));
};
var S = function(t2, r2, n2) {
  r2 = o(r2, -100, 100), n2 = o(n2, -100, 100);
  var e2 = Math.sqrt(r2 * r2 + n2 * n2), i2 = (180 * Math.atan2(n2, r2) / Math.PI + 360) % 360;
  return 0 === Math.round(1e4 * e2) && (i2 = Number.NaN), [t2, e2, i2];
};
var A = function(t2, r2, n2) {
  return isNaN(n2) && (n2 = 0), n2 *= Math.PI / 180, [t2, Math.cos(n2) * r2, Math.sin(n2) * r2];
};
var L = function(t2, r2, n2) {
  return P.apply(void 0, A(t2, r2, n2));
};
var H = function(t2, r2, n2) {
  var e2 = t2 + r2 + n2, o2 = 0, i2 = 0;
  return e2 > 0 && (o2 = t2 / e2, i2 = r2 / e2), [o2, i2, r2];
};
var Y = Object.freeze({ __proto__: null, linear2rgb: e, rgb2linear: n, rgb2hex: u, hex2rgb: h, rgb2cmyk: c, cmyk2rgb: l, rgb2hsl: f, hsl2rgb: s, rgb2hsv: v, hsv2rgb: b, rgb2hsi: y, hsi2rgb: d, rgb2hwb: g, hwb2rgb: w, rgb2xyz: z, xyz2rgb: N, xyz2lab: O, lab2xyz: P, rgb2lab: function(t2, r2, n2) {
  return O.apply(void 0, z(t2, r2, n2));
}, lab2rgb: j, lch2lab: A, lab2lch: S, xyz2lch: function(t2, r2, n2) {
  return S.apply(void 0, O(t2, r2, n2));
}, lch2xyz: L, xyY2xyz: function(t2, r2, n2) {
  return 0 === r2 ? [0, 0, 0] : [t2 * (n2 / r2), n2, n2 / r2 * (1 - t2 - r2)];
}, xyz2xyY: H });
function R(t2, n2) {
  return void 0 === n2 && (n2 = false), function(e2, o2, i2) {
    var a2 = i2.value;
    i2.value = function() {
      for (var e3 = [], o3 = 0; o3 < arguments.length; o3++)
        e3[o3] = arguments[o3];
      if (e3.length > 0 && n2) {
        var i3 = JSON.stringify(e3);
        t2 += i3;
      }
      if (this.cache.has(t2))
        return this.cache.get(t2);
      var u2 = a2.call.apply(a2, r([this], e3, false));
      return this.cache.set(t2, u2), u2;
    };
  };
}
function q(t2, n2, e2, o2) {
  return void 0 === t2 && (t2 = [0, 2, 2]), void 0 === n2 && (n2 = 0), void 0 === e2 && (e2 = true), void 0 === o2 && (o2 = 0), function(a2, u2, h2) {
    var c2 = h2.value;
    h2.value = function() {
      for (var a3 = [], u3 = 0; u3 < arguments.length; u3++)
        a3[u3] = arguments[u3];
      var h3 = void 0 === a3[o2] ? e2 : a3[o2], l2 = c2.call.apply(c2, r([this], a3, false));
      if (false === h3)
        return l2;
      var p2 = "number" == typeof h3 ? Math.round(h3) : 0, f2 = "number" == typeof t2 ? new Array(l2.length).fill(t2) : t2, s2 = f2.map(function(t3) {
        return 1 === n2 ? "number" == typeof h3 ? p2 : t3 : t3 + p2;
      });
      return l2.map(function(t3, r2) {
        return i(t3, s2[r2]);
      });
    };
  };
}
var D = function(t2, r2, n2) {
  var e2 = t2 instanceof ft ? t2 : new ft(t2), i2 = r2 instanceof ft ? r2 : new ft(r2), a2 = o(n2, 0, 100) / 100, u2 = 2 * a2 - 1, h2 = e2.alpha() - i2.alpha(), c2 = ((u2 * h2 == -1 ? u2 : (u2 + h2) / (1 + u2 * h2)) + 1) / 2, l2 = 1 - c2, p2 = [Math.round(o(e2.red() * c2 + i2.red() * l2, 0, 255)), Math.round(o(e2.green() * c2 + i2.green() * l2, 0, 255)), Math.round(o(e2.blue() * c2 + i2.blue() * l2, 0, 255))], f2 = e2.alpha() * a2 + i2.alpha() * (1 - a2);
  return new ft(p2, f2);
};
var F = Math.sqrt;
var U = Math.pow;
var $ = Math.cos;
var J = Math.abs;
var Z = Math.sin;
var B = Math.exp;
var G = Math.atan2;
var K = Math.PI;
var Q = function(t2) {
  return K * t2 / 180;
};
var T = function(t2, r2, n2) {
  void 0 === n2 && (n2 = true);
  var e2 = G(r2, t2);
  return n2 && (e2 = (e2 = (e2 = 180 * e2 / K) > 0 ? e2 : e2 + 360) > 360 ? e2 - 360 : e2), e2;
};
var V = function(t2, r2) {
  void 0 === r2 && (r2 = true);
  var n2 = t2.lab(false), e2 = n2[0], o2 = n2[1], i2 = n2[2];
  return [e2, F(U(o2, 2) + U(i2, 2)), T(o2, i2, r2), o2, i2];
};
var W = ["CMC", "CIE", "CIE2000", "CIE1994", "CIE1976"];
var X = "CMC";
var tt = "CIE2000";
var rt = "CIE1994";
var nt = "CIE1976";
var et = function(t2, r2, n2, e2) {
  void 0 === n2 && (n2 = "CIE");
  var o2 = function(t3) {
    var r3 = t3.toUpperCase();
    return W.includes(r3) && "CIE" !== r3 ? r3 : tt;
  }(n2);
  if (e2 = e2 || {}, o2 === X) {
    var i2 = Object.assign({}, { l: 1, c: 1 }, e2);
    return function(t3, r3, n3, e3) {
      void 0 === n3 && (n3 = 1), void 0 === e3 && (e3 = 1);
      var o3 = V(t3, true), i3 = o3[0], a3 = o3[1], u3 = o3[2], h3 = o3[3], c3 = o3[4], l2 = V(r3), p2 = l2[0], f2 = l2[1], s2 = l2[3], v2 = a3 - f2, b2 = i3 - p2, y2 = c3 - l2[4], d2 = F(U(h3 - s2, 2) + U(y2, 2) - U(v2, 2)), g2 = i3 < 16 ? 0.511 : 0.040975 * i3 / (1 + 0.01765 * i3), w2 = 0.0638 * a3 / (1 + 0.0131 * a3) + 0.638, m2 = 164 <= u3 && u3 <= 345 ? 0.56 + J(0.2 * $(Q(u3 + 168))) : 0.36 + J(0.4 * $(Q(u3 + 35))), M2 = F(U(a3, 4) / (U(a3, 4) + 1900)), x2 = w2 * (M2 * m2 + 1 - M2);
      return F(U(b2 / (n3 * g2), 2) + U(v2 / (e3 * w2), 2) + U(d2 / x2, 2));
    }(t2, r2, i2.l, i2.c);
  }
  if (o2 === rt) {
    var a2 = { kL: 1, kC: 1, kH: 1, cate: "graphic" }, u2 = Object.assign({}, a2, e2);
    return function(t3, r3, n3, e3, o3, i3) {
      void 0 === n3 && (n3 = 1), void 0 === e3 && (e3 = 1), void 0 === o3 && (o3 = 1), void 0 === i3 && (i3 = "graphic");
      var a3 = "textiles" === i3 ? 0.048 : 0.045, u3 = "textiles" === i3 ? 0.014 : 0.015;
      n3 = "textiles" === i3 ? 2 : n3;
      var h3 = V(t3), c3 = h3[0], l2 = h3[1], p2 = h3[3], f2 = h3[4], s2 = V(r3), v2 = s2[0], b2 = s2[1], y2 = s2[3], d2 = c3 - v2, g2 = l2 - b2, w2 = f2 - s2[4], m2 = 1 + a3 * l2, M2 = 1 + u3 * l2, x2 = F(U(p2 - y2, 2) + U(w2, 2) - U(g2, 2));
      return F(U(d2 / (1 * n3), 2) + U(g2 / (e3 * m2), 2) + U(x2 / (o3 * M2), 2));
    }(t2, r2, u2.kL, u2.kC, u2.kH, u2.cate);
  }
  if (o2 === nt)
    return function(t3, r3) {
      var n3 = t3.lab(false), e3 = n3[0], o3 = n3[1], i3 = n3[2], a3 = r3.lab(false), u3 = a3[0], h3 = a3[1], c3 = a3[2];
      return F(U(e3 - u3, 2) + U(o3 - h3, 2) + U(i3 - c3, 2));
    }(t2, r2);
  var h2 = { kL: 1, kC: 1, kH: 1 }, c2 = Object.assign({}, h2, e2);
  return function(t3, r3, n3, e3, o3) {
    void 0 === n3 && (n3 = 1), void 0 === e3 && (e3 = 1), void 0 === o3 && (o3 = 1);
    var i3 = V(t3), a3 = i3[0], u3 = i3[1], h3 = i3[3], c3 = i3[4], l2 = V(r3), p2 = l2[0], f2 = l2[1], s2 = l2[3], v2 = l2[4], b2 = (a3 + p2) / 2, y2 = (u3 + f2) / 2, d2 = (1 - F(U(y2, 7) / (U(y2, 7) + U(25, 7)))) / 2, g2 = h3 * (1 + d2), w2 = s2 * (1 + d2), m2 = F(U(g2, 2) + U(c3, 2)), M2 = F(U(w2, 2) + U(v2, 2)), x2 = T(g2, c3, true), _2 = T(w2, v2, true), C2 = (m2 + M2) / 2, I2 = J(x2 - _2) > 180 ? (x2 + _2 + 360) / 2 : (x2 + _2) / 2, k2 = 1 - 0.17 * $(Q(I2 - 30)) + 0.24 * $(Q(2 * I2)) + 0.32 * $(Q(3 * I2 + 6)) - 0.2 * $(Q(4 * I2 - 63)), E2 = J(_2 - x2) <= 180 ? _2 - x2 : J(_2 - x2) > 180 && _2 <= x2 ? _2 - x2 + 360 : _2 - x2 - 360, z2 = p2 - a3, N2 = f2 - u3, O2 = 2 * F(m2 * M2) * Z(Q(E2) / 2), P2 = 1 + 0.015 * U(b2 - 50, 2) / F(20 + U(b2 - 50, 2)), j2 = 1 + 0.045 * C2, S2 = 1 + 0.015 * C2 * k2, A2 = 30 * B(-U((I2 - 275) / 25, 2)), L2 = -2 * F(U(C2, 7) / (U(C2, 7) + U(25, 7))) * Z(2 * Q(A2));
    return F(U(z2 / (n3 * P2), 2) + U(N2 / (e3 * j2), 2) + U(O2 / (o3 * S2), 2) + L2 * (N2 / (e3 * j2)) * (O2 / (o3 * S2)));
  }(t2, r2, c2.kL, c2.kC, c2.kH);
};
var ot = function(t2, r2, n2) {
  var e2 = Math.abs, o2 = Math.max, i2 = Math.min, a2 = t2 instanceof ft ? t2 : new ft(t2), u2 = r2 instanceof ft ? r2 : new ft(r2), h2 = Object.assign({}, { b: 125, c: 500 }, n2);
  return !(e2(255 * a2.brightness() / 100 - 255 * u2.brightness() / 100) <= h2.b) && !(o2(a2.red(), u2.red()) - i2(a2.red(), u2.red()) + (o2(a2.green(), u2.green()) - i2(a2.green(), u2.green())) + (o2(a2.blue(), u2.blue()) - i2(a2.blue(), u2.blue())) <= h2.c);
};
var it = function(t2, r2, n2) {
  var e2, i2 = function(t3) {
    return o(t3, 0, 100);
  }, a2 = function(t3) {
    return o(t3, 0, 255);
  }, u2 = { h: [0, function(t3) {
    return t3 % 360;
  }], s: [1, i2], l: [2, i2], r: [0, a2], g: [1, a2], b: [2, a2] }, h2 = u2[r2][0];
  if (["h", "s", "l"].includes(r2)) {
    var c2 = t2.hsl();
    if (void 0 === n2)
      return c2[h2];
    n2 = u2[r2][1](n2), c2[h2] = n2, e2 = s.apply(void 0, c2);
  } else {
    if (e2 = t2.rgb(), void 0 === n2)
      return e2[h2];
    n2 = u2[r2][1](n2), e2[h2] = n2;
  }
  return new ft(e2, t2.alpha());
};
var at = {};
var ut = /* @__PURE__ */ new Set(["rgb", "rgba", "cmyk", "lab", "hsl", "hsla", "hsv", "hsva", "hsi", "hsia", "xyz", "lch", "hwb", "hwba"]);
var ht = /^([a-zA-Z]+)\(([\s\S]+)\)$/;
var ct = function(t2) {
  return "string" == typeof t2 ? -1 === t2.indexOf("%") ? ct(Number(t2.trim())) : (t2 = t2.split("%")[0], (t2 = Number(t2.trim())) || 0) : Math.abs(t2) < 1 ? 100 * t2 : t2;
};
var lt = function(t2, r2) {
  void 0 === r2 && (r2 = /* @__PURE__ */ new Set());
  var n2 = "string" == typeof t2 ? t2 : t2.join(",");
  if (r2.has(n2))
    throw new Error("Invalid Color");
  r2.add(n2);
  var e2 = "rgb", o2 = [0, 0, 0], i2 = 100;
  if (Array.isArray(t2)) {
    if (t2.length < 3)
      throw new Error("Invalid Color");
    for (var a2 = 0; a2 < t2.length; a2++)
      if (a2 < 3)
        o2[a2] = t2[a2];
      else {
        if (3 !== a2 || void 0 === t2[3])
          break;
        i2 = t2[3];
      }
  } else {
    var u2 = false, c2 = t2.trim().match(ht);
    if (c2 || (u2 = true), c2) {
      var l2 = c2[1].toLocaleLowerCase();
      if (e2 = l2, ut.has(l2) || (u2 = true), c2[2] && !u2) {
        var p2 = c2[2], f2 = -1 !== p2.indexOf(",") ? "," : " ", s2 = p2.split(f2);
        for (a2 = 0; a2 < 3; a2++)
          void 0 !== s2[a2] && (["lch", "lab"].includes(e2) && 0 === a2 || ["hsl", "hsla", "hsv", "hsva", "hwb", "hwba", "hsi", "hsia"].includes(e2) && a2 > 0 ? o2[a2] = ct(s2[a2]) : o2[a2] = Number(s2[a2].trim()));
        ["rgba", "hsla", "hsva", "hwba", "hsia"].includes(e2) ? (e2 = e2.slice(0, -1), void 0 !== s2[3] && (i2 = ct(s2[3]))) : "cmyk" === e2 && o2.push(void 0 !== s2[3] ? ct(s2[3]) : 0);
      }
    }
    if (u2) {
      if (!/^#(([a-fA-F\d]{3}){1,2}|[a-fA-F\d]{8})$/.test(t2))
        try {
          return t2 = function(t3, r3) {
            if (void 0 === r3 && (r3 = false), t3 = t3.toLowerCase(), void 0 === at[t3]) {
              if (r3)
                throw new Error("Unknown color name: ".concat(t3, ")"));
              return t3;
            }
            return at[t3];
          }(t2, true), lt(t2, r2);
        } catch (t3) {
          throw new Error("Invalid Color");
        }
      o2 = h(t2);
    }
  }
  return [e2, o2, i2];
};
var pt = { thowParseError: false };
var ft = function() {
  function n2(t2, r2, n3) {
    this.cache = /* @__PURE__ */ new Map(), this._rgb = [0, 0, 0], this._alpha = 100;
    var e2 = { thowParseError: pt.thowParseError }, i2 = Object.assign({}, e2, null != n3 ? n3 : {});
    try {
      var a2 = function(t3) {
        var r3, n4 = { lab2rgb: j, hsl2rgb: s, hsv2rgb: b, xyz2rgb: N, hwb2rgb: w, hsi2rgb: d }, e3 = lt(t3), i3 = e3[0], a3 = e3[1], u3 = e3[2];
        if ("rgb" === i3)
          return [a3, u3];
        "lch" === i3 && (i3 = (r3 = ["xyz", L(a3[0], a3[1], a3[2])])[0], a3 = r3[1]);
        var h3 = a3[0], c2 = a3[1], p2 = a3[2], f2 = a3[3];
        if ("cmyk" === i3)
          return [l(h3, c2, p2, f2).map(function(t4) {
            return o(t4, 0, 255);
          }), u3];
        var v2 = "".concat(i3, "2rgb");
        if ("function" == typeof n4[v2])
          return [n4[v2](h3, c2, p2).map(function(t4) {
            return o(t4, 0, 255);
          }), u3];
        throw new Error("Invalid color");
      }(t2), u2 = a2[0], h2 = a2[1];
      this._alpha = h2, this._rgb = u2;
    } catch (t3) {
      if (i2.thowParseError)
        throw t3;
    }
    void 0 !== r2 && (this._alpha = o(r2, 0, 100));
  }
  return n2.prototype.red = function(t2) {
    return it(this, "r", t2);
  }, n2.prototype.green = function(t2) {
    return it(this, "g", t2);
  }, n2.prototype.blue = function(t2) {
    return it(this, "b", t2);
  }, n2.prototype.alpha = function(t2) {
    return void 0 === t2 ? this._alpha : (t2 = o(t2, 0, 100), new n2(this.rgb(), t2));
  }, n2.prototype.fadeIn = function(t2, r2) {
    return void 0 === t2 && (t2 = 10), t2 = r2 && "relative" === r2 ? this._alpha * t2 / 100 : t2, new n2(this.rgb(), o(this._alpha + t2, 0, 100));
  }, n2.prototype.fadeOut = function(t2, r2) {
    return void 0 === t2 && (t2 = 10), t2 = r2 && "relative" === r2 ? this._alpha * t2 / 100 : t2, new n2(this.rgb(), o(this._alpha - t2, 0, 100));
  }, n2.prototype.opacify = function(t2, r2) {
    return void 0 === t2 && (t2 = 10), this.fadeIn(t2, r2);
  }, n2.prototype.transparentize = function(t2, r2) {
    return void 0 === t2 && (t2 = 10), this.fadeOut(t2, r2);
  }, n2.prototype.hue = function(t2) {
    return it(this, "h", t2);
  }, n2.prototype.saturation = function(t2) {
    return it(this, "s", t2);
  }, n2.prototype.lightness = function(t2) {
    return it(this, "l", t2);
  }, n2.prototype.rgb = function(t2) {
    return r([], this._rgb, true);
  }, n2.prototype.rgba = function(t2) {
    return r(r([], this.rgb(false), true), [this._alpha], false);
  }, n2.prototype.cmyk = function(t2) {
    return c.apply(void 0, this._rgb);
  }, n2.prototype.hsl = function(t2) {
    return f.apply(void 0, this._rgb);
  }, n2.prototype.hsla = function(t2) {
    return r(r([], this.hsl(false), true), [this._alpha], false);
  }, n2.prototype.hsv = function(t2) {
    return v.apply(void 0, this._rgb);
  }, n2.prototype.hsi = function(t2) {
    return y.apply(void 0, this._rgb);
  }, n2.prototype.hwb = function(t2) {
    return g.apply(void 0, this._rgb);
  }, n2.prototype.xyz = function(t2) {
    return z.apply(void 0, this._rgb);
  }, n2.prototype.lab = function(t2) {
    return O.apply(void 0, this.xyz(false));
  }, n2.prototype.lch = function(t2) {
    return S.apply(void 0, this.lab(false));
  }, n2.prototype.xyY = function(t2) {
    return H.apply(void 0, this.xyz(false));
  }, n2.prototype.hex = function(t2) {
    void 0 === t2 && (t2 = 2);
    var n3 = 0 === t2 ? void 0 : 1 === t2 ? this._alpha : 100 === this._alpha ? void 0 : this._alpha, e2 = "color:hex:param_".concat(t2);
    if (this.cache.has(e2))
      return this.cache.get(e2);
    var o2 = u.apply(void 0, r(r([], this._rgb, false), [n3], false));
    return this.cache.set(e2, o2), o2;
  }, n2.prototype.lighten = function(t2, r2) {
    void 0 === t2 && (t2 = 5);
    var e2 = this.hsl(false), i2 = e2[0], a2 = e2[1], u2 = e2[2];
    return u2 = o(u2 += void 0 !== r2 && "relative" === r2 ? u2 * (t2 / 100) : t2, 0, 100), new n2(s(i2, a2, u2), this._alpha);
  }, n2.prototype.darken = function(t2, r2) {
    return void 0 === t2 && (t2 = 5), this.lighten(-t2, r2);
  }, n2.prototype.saturate = function(t2, r2) {
    void 0 === t2 && (t2 = 5);
    var e2 = this.hsl(false), i2 = e2[0], a2 = e2[1], u2 = e2[2];
    return a2 = o(a2 += void 0 !== r2 && "relative" === r2 ? a2 * (t2 / 100) : t2, 0, 100), new n2(s(i2, a2, u2), this._alpha);
  }, n2.prototype.desaturate = function(t2, r2) {
    return void 0 === t2 && (t2 = 5), this.saturate(-t2, r2);
  }, n2.prototype.spin = function(t2) {
    var r2 = this.hsl(false), e2 = r2[0], o2 = r2[1], i2 = r2[2];
    return new n2(s(e2 = (e2 + t2 % 360 + 360) % 360, o2, i2), this._alpha);
  }, n2.prototype.adjustHue = function(t2) {
    return this.spin(t2);
  }, n2.prototype.complement = function() {
    return this.spin(180);
  }, n2.prototype.invert = function() {
    var t2 = this._rgb.map(function(t3) {
      return 255 - t3;
    });
    return new n2([t2[0], t2[1], t2[2]], this._alpha);
  }, n2.prototype.mix = function(t2, r2) {
    return void 0 === r2 && (r2 = 50), D(this, t2, 100 - o(r2, 0, 100));
  }, n2.prototype.luma = function() {
    var t2 = this._rgb.map(function(t3) {
      return (t3 /= 255) <= 0.03928 ? t3 / 12.92 : Math.pow((t3 + 0.055) / 1.055, 2.4);
    });
    return 0.2126 * t2[0] + 0.7152 * t2[1] + 0.0722 * t2[2];
  }, n2.prototype.brightness = function() {
    var t2 = this._rgb;
    return function(t3, r2, n3) {
      return (299 * t3 + 587 * r2 + 114 * n3) / 1e3 / 255 * 100;
    }(t2[0], t2[1], t2[2]);
  }, n2.prototype.deltaE = function(t2, r2, n3) {
    return void 0 === r2 && (r2 = "CMC"), et(this, t2, r2, n3);
  }, n2.prototype.visibility = function(t2, r2) {
    return ot(this, t2, r2);
  }, t([q(0, 1, true, 0), R("color:rgb")], n2.prototype, "rgb", null), t([q(0, 1, true, 0)], n2.prototype, "rgba", null), t([q(0, 1, true, 0), R("color:cmyk")], n2.prototype, "cmyk", null), t([q(0, 1, true, 0), R("color:hsl")], n2.prototype, "hsl", null), t([q(0, 1, true, 0)], n2.prototype, "hsla", null), t([q(0, 1, true, 0), R("color:hsv")], n2.prototype, "hsv", null), t([q(0, 1, true, 0), R("color:hsi")], n2.prototype, "hsi", null), t([q(0, 1, true, 0), R("color: hwb")], n2.prototype, "hwb", null), t([q(2, 1, true, 0), R("color:xyz")], n2.prototype, "xyz", null), t([q(2, 1, true, 0), R("color:lab")], n2.prototype, "lab", null), t([q(2, 1, true, 0), R("color:lch")], n2.prototype, "lch", null), t([q(2, 1, true, 0), R("color:xyY")], n2.prototype, "xyY", null), t([R("color:luma")], n2.prototype, "luma", null), n2;
}();
var st = function(t2, r2, n2, e2) {
  return new ft([t2, r2, n2], e2);
};
var vt = function(t2, r2, n2, e2) {
  return new ft(s(t2, r2, n2), e2);
};
var bt = function(t2, r2, n2, e2) {
  return new ft(b(t2, r2, n2), e2);
};
var yt = function(t2, r2, n2, e2) {
  return new ft(d(t2, r2, n2), e2);
};
var dt = function(t2, r2, n2, e2) {
  return new ft(w(t2, r2, n2), e2);
};
var gt = function(t2, r2, n2, e2) {
  return new ft(N(t2, r2, n2), e2);
};
var wt = function(t2, r2, n2, e2) {
  return new ft(j(t2, r2, n2), e2);
};
var mt = function(t2, r2, n2, e2) {
  return new ft(N.apply(void 0, L(t2, r2, n2)), e2);
};
function Mt(t2, r2, n2) {
  return new ft(t2, r2, n2);
}
Mt.config = function(t2) {
  Object.assign(pt, t2);
}, Mt.random = function() {
  var t2 = a(0, 255), r2 = a(0, 255), n2 = a(0, 255);
  return new ft([t2, r2, n2]);
}, Mt.convertor = Y, Mt.Color = ft, Mt.rgb = st, Mt.hsl = vt, Mt.hsv = bt, Mt.hsi = yt, Mt.hwb = dt, Mt.xyz = gt, Mt.lab = wt, Mt.lch = mt, Mt.mix = D, Mt.deltaE = et, Mt.utils = { roundDecimal: i, randomRange: a }, Mt.useNames = function(t2, r2) {
  return function(t3, r3) {
    if (void 0 !== r3 && "function" == typeof r3) {
      var n2 = {};
      for (var e2 in t3) {
        var o2 = r3(e2, t3[e2]), i2 = o2[0], a2 = o2[1];
        n2[i2] = a2;
      }
      Object.assign(at, n2);
    } else
      Object.assign(at, t3);
  }(t2, r2), Mt;
};

// src/components/PaletteItem.ts
var import_obsidian3 = require("obsidian");

// src/utils/EventEmitter.ts
var EventEmitter = class {
  constructor() {
    this.eventListeners = {};
  }
  on(eventName, listener) {
    var _a;
    const listeners = (_a = this.eventListeners[eventName]) != null ? _a : /* @__PURE__ */ new Set();
    listeners.add(listener);
    this.eventListeners[eventName] = listeners;
  }
  off(eventName, listener) {
    var _a;
    const listeners = (_a = this.eventListeners[eventName]) != null ? _a : /* @__PURE__ */ new Set();
    listeners.delete(listener);
    this.eventListeners[eventName] = listeners;
  }
  emit(eventName, ...args) {
    var _a;
    const listeners = (_a = this.eventListeners[eventName]) != null ? _a : /* @__PURE__ */ new Set();
    for (const listener of listeners) {
      listener(...args);
    }
  }
  clear() {
    this.eventListeners = {};
  }
};

// src/components/PaletteItem.ts
var PaletteItem = class {
  constructor(container, color, settings) {
    this.container = container.createEl("div");
    this.color = color.trim();
    this.settings = settings;
    this.emitter = new EventEmitter();
    this.load();
  }
  load() {
    const csColor = Mt(this.color);
    this.container.style.setProperty("--palette-background-color", this.color);
    this.container.style.setProperty("--palette-column-flex-basis", (this.settings.height / this.settings.colorCount / 2).toString() + "px");
    const incompatibleSettings = this.settings.direction === "row" /* Row */;
    if (this.settings.editMode && !incompatibleSettings) {
      new EditMode(this.container, this.color, this.settings, (e2) => this.emitter.emit("trash", e2), (alias) => this.emitter.emit("alias", alias));
    } else {
      if (this.settings.aliasMode === "Both" /* Both */ || this.settings.alias == null || this.settings.alias.trim() === "") {
        let childText = this.container.createEl("span", { text: this.color.toUpperCase() });
        childText.style.setProperty("--palette-color", getForegroundColor(csColor));
      }
      let childAlias = this.container.createEl("span", { text: this.settings.alias });
      childAlias.style.setProperty("--palette-color", getForegroundColor(csColor));
    }
    this.container.addEventListener("click", (e2) => this.emitter.emit("click", e2));
  }
  /**
   * Removes listeners
   */
  unload() {
    this.emitter.clear();
  }
};
var EditMode = class {
  constructor(colorContainer, color, settings, onTrash, onAlias) {
    this.color = color;
    this.settings = settings;
    this.onTrash = onTrash;
    this.onAlias = onAlias;
    const csColor = Mt(color);
    const contrastColor = getForegroundColor(csColor);
    this.container = colorContainer.appendChild(createEl("div"));
    this.container.addClass("edit-container");
    this.container.style.setProperty("--edit-background-color", color);
    this.container.style.setProperty("--edit-color", contrastColor);
    this.span = this.container.createEl("span");
    this.span.setText(settings.alias || color.toUpperCase());
    this.span.style.setProperty("--edit-font-size", `${this.getAdjustedFontSize(settings.colorCount)}px`);
    this.trash = new import_obsidian3.ButtonComponent(this.container).setIcon("trash-2").setTooltip("Remove").onClick((e2) => this.onTrash(e2));
    this.trash.buttonEl.addEventListener("mouseover", (e2) => {
      this.trash.setCta();
    });
    this.trash.buttonEl.addEventListener("mouseout", (e2) => {
      this.trash.removeCta();
    });
    this.span.addEventListener("click", (e2) => {
      e2.stopPropagation();
      this.setEditable(true);
      this.span.focus();
    });
    this.span.addEventListener("contextmenu", (e2) => {
      e2.stopPropagation();
      this.span.setText(this.color.toUpperCase());
      this.settings.alias = "";
      this.onAlias(this.settings.alias);
    });
    this.span.addEventListener("keypress", (e2) => {
      if (e2.key === "Enter") {
        this.setAlias();
        this.setEditable(false);
      }
    });
    this.span.addEventListener("focusout", (e2) => {
      this.setAlias();
      this.setEditable(false);
    });
    this.storedAlias = this.span.getText();
  }
  setAlias() {
    if (this.span.getText().trim() === "")
      this.span.setText(this.storedAlias);
    else if (this.span.getText() !== this.color) {
      this.settings.alias = this.span.getText();
      this.onAlias(this.settings.alias);
    }
  }
  setEditable(editable) {
    if (editable === true) {
      this.storedAlias = this.span.getText();
      this.span.setText("");
    }
    this.span.contentEditable = `${editable}`;
    this.span.toggleClass("color-span-editable", editable);
  }
  /**
   * Calculate font size based on number of colors
   */
  getAdjustedFontSize(colorsCount) {
    const minFontSize = 10;
    const baseFontSize = 16;
    return Math.max(minFontSize, baseFontSize - colorsCount);
  }
};

// src/utils/dragDropUtils.ts
var DragDrop = class {
  constructor(dropzones, draggables, onDrop) {
    this.dropzones = dropzones;
    this.draggables = draggables;
    this.result = { beforeElement: null, insertedElement: null, afterElement: null, order: this.draggables };
    this.onDrop = onDrop;
    this.load();
  }
  dragStart(draggable, e2) {
    draggable.toggleClass("is-dragging", true);
  }
  dragOver(dropzone, e2) {
    if (e2.dataTransfer) {
      const hasElement = Array.from(e2.dataTransfer.items).some((item) => {
        return item.kind !== "element";
      });
      if (hasElement)
        return;
    }
    e2.preventDefault();
    this.result.beforeElement = this.getDragBeforeElement(e2.clientX);
    this.result.insertedElement = this.getDraggingElement();
    this.result.afterElement = this.getDragAfterElement(e2.clientX);
    const insertedIndex = this.draggables.indexOf(this.result.insertedElement);
    if (this.result.afterElement === null) {
      dropzone.appendChild(this.result.insertedElement);
      this.result.order.splice(insertedIndex, 1);
      this.result.order.push(this.result.insertedElement);
    } else {
      dropzone.insertBefore(this.result.insertedElement, this.result.afterElement);
      this.result.order.splice(insertedIndex, 1);
      const afterIndex = this.draggables.indexOf(this.result.afterElement);
      this.result.order.splice(afterIndex, 0, this.result.insertedElement);
    }
  }
  dragEnd(draggable, e2) {
    draggable.toggleClass("is-dragging", false);
    this.onDrop(e2, this.result);
    this.result = { beforeElement: null, insertedElement: null, afterElement: null, order: this.draggables };
  }
  load() {
    for (let draggable of this.draggables) {
      draggable.setAttribute("draggable", "true");
      draggable.addEventListener("dragstart", (e2) => this.dragStart(draggable, e2));
      draggable.addEventListener("dragend", (e2) => this.dragEnd(draggable, e2));
    }
    for (let dropzone of this.dropzones) {
      dropzone.addEventListener("dragover", (e2) => this.dragOver(dropzone, e2));
    }
  }
  unload() {
    for (let draggable of this.draggables) {
      draggable.removeEventListener("dragstart", (e2) => this.dragStart(draggable, e2));
      draggable.removeEventListener("dragend", (e2) => this.dragEnd(draggable, e2));
    }
    for (let dropzone of this.dropzones) {
      dropzone.removeEventListener("dragover", (e2) => this.dragOver(dropzone, e2));
    }
  }
  /**
   * @returns The element which is being dragged
   */
  getDraggingElement() {
    return this.draggables.filter((draggable) => draggable.hasClass("is-dragging"))[0];
  }
  /**
   * @returns All draggable elements not being dragged
   */
  getDraggableElements() {
    return this.draggables.filter((draggable) => !draggable.hasClass("is-dragging"));
  }
  /**
   * Gets the closest element before the dragged element
   */
  getDragBeforeElement(x2) {
    return this.getDraggableElements().reduce(
      (closest, child) => {
        const rect = child.getBoundingClientRect();
        const leftPosition = x2 - rect.left;
        const halfChildWidth = rect.width / 2;
        const offset = leftPosition - halfChildWidth;
        if (offset > 0 && offset < closest.offset)
          return { offset, element: child };
        else
          return closest;
      },
      // Initial closest value
      { offset: Number.POSITIVE_INFINITY, element: null }
    ).element;
  }
  /**
   * Gets the closest element after the dragged element
   */
  getDragAfterElement(x2) {
    return this.getDraggableElements().reduce(
      (closest, child) => {
        const rect = child.getBoundingClientRect();
        const leftPosition = x2 - rect.left;
        const halfChildWidth = rect.width / 2;
        const offset = leftPosition - halfChildWidth;
        if (offset < 0 && offset > closest.offset)
          return { offset, element: child };
        else
          return closest;
      },
      // Initial closest value
      { offset: Number.NEGATIVE_INFINITY, element: null }
    ).element;
  }
};

// src/utils/canvasUtils.ts
var import_validate_color = __toESM(require_lib());
var Canvas = class {
  constructor(container) {
    this.container = container;
    this.container.addClass("palette-canvas");
    this.canvas = container.appendChild(document.createElement("canvas"));
    this.tooltip = container.appendChild(document.createElement("section"));
    this.tooltip.addClasses(["tooltip", "palette-tooltip"]);
    this.tooltipText = this.tooltip.appendChild(document.createElement("span"));
    this.context = this.canvas.getContext("2d", { willReadFrequently: true, alpha: true });
    this.emitter = new EventEmitter();
    if (!this.isTouchEnabled())
      this.canvas.addEventListener("mousemove", (e2) => this.setTooltipPosition(e2.clientX, e2.clientY));
    else
      this.canvas.addEventListener("touchmove", (e2) => this.setTooltipPosition(e2.touches[0].clientX, e2.touches[0].clientY));
    this.canvas.addEventListener("click", (e2) => this.emitter.emit("click", this.getCanvasHex(e2.clientX, e2.clientY)));
  }
  /**
   * Creates a new gradient canvas
   * @param colors 
   * @param width 
   * @param height 
   * @param direction
   * @param onClick canvas click callback
   */
  createGradient(colors, width, height, direction) {
    this.canvas.width = width;
    this.canvas.height = height;
    let gradient = direction === "column" /* Column */ ? this.context.createLinearGradient(0, 0, width, 0) : this.context.createLinearGradient(0, 0, 0, height);
    let colorStops = [];
    for (const [i2, color] of colors.entries()) {
      if ((0, import_validate_color.default)(color)) {
        gradient.addColorStop(i2 / (colors.length - 1), color);
        colorStops.push(color);
      }
    }
    if (colorStops.length <= 1)
      throw new Error("There are not enough valid color stops to create the gradient.");
    this.context.fillStyle = gradient || "#000";
    this.context.fillRect(0, 0, width, height);
    this.canvas.toggleClass("gradient", true);
    this.canvas.style.setProperty("--palette-column-flex-basis", (height / colors.length / 2).toString() + "px");
  }
  // Retrieves the hex from the mouse position
  getCanvasHex(clientX, clientY) {
    const canvasBounds = this.canvas.getBoundingClientRect();
    let x2 = clientX - canvasBounds.left;
    let y2 = clientY - canvasBounds.top;
    let [r2, g2, b2, a2] = this.context.getImageData(x2, y2, 1, 1).data;
    const alpha = Math.round(a2 / 255 * 100);
    let hex = alpha !== 255 ? Mt([r2, g2, b2, alpha]).hex() : Mt([r2, g2, b2]).hex();
    return hex;
  }
  /**
   * Sets the tooltip position based on current cursor or touch position
   */
  setTooltipPosition(clientX, clientY) {
    const rect = this.canvas.getBoundingClientRect();
    let tooltipWidth = this.tooltip.offsetWidth;
    let tooltipHeight = this.tooltip.offsetHeight;
    let leftPosition = clientX - rect.left > rect.width / 2 ? clientX - rect.left - 56 : clientX - rect.left + 64;
    let halfTooltipWidth = tooltipWidth / 2;
    if (leftPosition < 0 + halfTooltipWidth)
      leftPosition = 0 + halfTooltipWidth;
    else if (leftPosition + tooltipWidth > rect.width + halfTooltipWidth)
      leftPosition = rect.width - tooltipWidth + halfTooltipWidth;
    this.tooltip.style.left = leftPosition + "px";
    let topPosition = clientY - rect.top - tooltipHeight / 4;
    if (topPosition < 0)
      topPosition = 0;
    else if (topPosition + tooltipHeight > rect.height)
      topPosition = rect.height - tooltipHeight;
    this.tooltip.style.top = topPosition + "px";
    const hex = this.getCanvasHex(clientX, clientY);
    this.tooltipText.setText(hex.toUpperCase());
  }
  /**
   * Checks for touch device
   */
  isTouchEnabled() {
    return "ontouchstart" in window || navigator.maxTouchPoints > 0;
  }
};

// src/components/Palette.ts
var Palette = class {
  constructor(colors, settings, containerEl, pluginSettings, editMode = false) {
    this.containerEl = containerEl;
    this.containerEl.addClass("palette-container");
    this.pluginSettings = pluginSettings;
    this.status = "Valid" /* VALID */;
    this.showNotice = true;
    this.editMode = editMode;
    this.paletteItems = [];
    this.emitter = new EventEmitter();
    this.setDefaults(colors, settings);
    this.load();
    let observerDebouncers = /* @__PURE__ */ new WeakMap();
    const resizeObserver = new ResizeObserver((palettes) => {
      palettes.forEach((palette) => {
        clearTimeout(observerDebouncers.get(palette.target));
        observerDebouncers.set(palette.target, setTimeout(() => this.emitter.emit("resized", palette), this.pluginSettings.reloadDelay));
      });
    });
    resizeObserver.observe(this.containerEl);
    this.emitter.on("resized", (palette) => this.onResized(palette));
  }
  /**
   * Sets the initial defaults
   */
  setDefaults(colors, settings) {
    if (typeof settings === "string") {
      this.settings = pluginToPaletteSettings(this.pluginSettings);
      this.status = "Invalid Settings" /* INVALID_SETTINGS */;
    }
    if (typeof settings === "object") {
      this.settings = { ...pluginToPaletteSettings(this.pluginSettings), ...settings };
    }
    if (typeof settings === "undefined") {
      this.settings = pluginToPaletteSettings(this.pluginSettings);
    }
    if (typeof colors === "string") {
      this.colors = [];
      this.status = this.status === "Invalid Settings" /* INVALID_SETTINGS */ ? "Invalid Colors & Settings" /* INVALID_COLORS_AND_SETTINGS */ : "Invalid Colors" /* INVALID_COLORS */;
    }
    if (typeof colors === "object") {
      this.colors = colors;
    }
  }
  /**
   * Loads the palette
   */
  load() {
    this.createPalette(this.colors, this.settings);
    if (this.editMode && !this.settings.gradient) {
      this.dropzone.toggleClass("palette-hover", !this.pluginSettings.stabilityWhileEditing);
      this.dropzone.toggleClass("palette-hide-text", !this.pluginSettings.stabilityWhileEditing);
      this.dragDrop = new DragDrop([this.dropzone], Array.from(this.dropzone.children), (e2, res) => {
        this.paletteItems.sort((a2, b2) => {
          return res.order.indexOf(a2.container) - res.order.indexOf(b2.container);
        });
        this.colors = this.paletteItems.map((item) => item.color);
        this.settings.aliases = this.paletteItems.map((item) => item.settings.alias);
        this.emitter.emit("changed", this.colors, this.settings);
        this.reload();
      });
    }
    this.dropzone.toggleClass("edit-mode", this.editMode);
  }
  /**
   * Unloads the palette
   */
  unload() {
    this.emitter.clear();
    this.paletteItems.forEach((item) => item.unload());
    this.containerEl.empty();
    this.paletteItems = [];
    this.paletteCanvas = void 0;
  }
  /**
   * Reloads the palette contents
   * @param resize Whether the palette is reloading because of a resize (defaults to false)
   */
  reload(resize = { height: 0, width: 0 }) {
    const isZero = resize.height === 0 && resize.width === 0;
    if (!isZero) {
      this.setWidth(this.getPaletteWidth(resize.width));
      return;
    }
    this.showNotice = !resize;
    this.unload();
    this.setDefaults(this.colors, this.settings);
    this.load();
    this.showNotice = true;
  }
  onResized(palette) {
    const size = { height: palette.contentRect.height, width: palette.contentRect.width };
    const isZero = size.height === 0 && size.width === 0;
    if (!isZero)
      this.reload({ height: size.height, width: size.width });
  }
  /**
   * Sets the width of the palette
   */
  setWidth(width) {
    if (this.settings.gradient && this.paletteCanvas)
      this.paletteCanvas.createGradient(this.colors, width, this.settings.height, this.settings.direction);
    this.dropzone.style.setProperty("--palette-width", `${width}px`);
    this.containerEl.toggleClass("palette-scroll", width > defaultSettings.width);
  }
  /**
   * @returns `user` OR `auto` width based on which is more appropriate
   */
  getPaletteWidth(resizeOffset = 0) {
    const paletteOffset = resizeOffset !== 0 ? resizeOffset : this.dropzone.offsetWidth;
    if (this.settings.width > defaultSettings.width)
      return this.settings.width;
    if (paletteOffset < this.settings.width && paletteOffset > 0)
      return paletteOffset;
    else
      return this.settings.width;
  }
  /**
   * Creates a new notice using pre-set settings
   * @param message Message to display
   */
  createNotice(message) {
    this.showNotice && new import_obsidian4.Notice(message, this.pluginSettings.noticeDuration);
  }
  setEditMode(editMode) {
    this.editMode = editMode;
    this.emitter.emit("editMode", editMode);
  }
  getEditMode() {
    return this.editMode;
  }
  /**
   * Create new palette contents based on colors & settings
   * @param colors 
   * @param settings 
   */
  createPalette(colors, settings) {
    this.dropzone = this.containerEl.createEl("div");
    this.dropzone.addClass("palette");
    this.dropzone.style.setProperty("--palette-corners", this.pluginSettings.corners ? "5px" : "0px");
    this.dropzone.style.setProperty("--palette-direction", settings.direction === "row" /* Row */ ? "column" /* Column */ : "row" /* Row */);
    this.dropzone.style.setProperty("--not-palette-direction", settings.direction);
    this.dropzone.style.setProperty("--palette-height", `${settings.height}px`);
    this.dropzone.toggleClass("palette-hover", settings.hover);
    this.dropzone.toggleClass("palette-hide-text", settings.hideText);
    try {
      if (this.status !== "Valid" /* VALID */)
        throw new PaletteError(this.status);
      this.settings.gradient ? this.createGradientPalette(this.dropzone, colors) : this.createColorPalette(this.dropzone, colors, settings);
      this.setWidth(this.getPaletteWidth());
    } catch (err) {
      if (err instanceof PaletteError)
        this.createInvalidPalette(err.status, err.message);
      else
        this.createNotice(err);
    }
  }
  createGradientPalette(container, colors) {
    if (colors.length <= 1)
      throw new PaletteError("Invalid Gradient" /* INVALID_GRADIENT */);
    this.paletteCanvas = new Canvas(container);
    this.paletteCanvas.emitter.on("click", async (color) => await copyToClipboard(color.toUpperCase(), this.pluginSettings.copyFormat));
  }
  createColorPalette(container, colors, settings) {
    var _a;
    for (const [i2, color] of colors.entries()) {
      const paletteItem = new PaletteItem(
        container,
        color,
        {
          aliasMode: this.pluginSettings.aliasMode,
          editMode: this.editMode,
          stabilityWhileEditing: this.pluginSettings.stabilityWhileEditing,
          height: settings.height,
          direction: settings.direction,
          hover: settings.hover,
          hideText: settings.hideText,
          alias: ((_a = settings.aliases) == null ? void 0 : _a[i2]) || "",
          colorCount: colors.length
        }
      );
      paletteItem.emitter.on("click", async (e2) => await copyToClipboard(color.toUpperCase(), this.pluginSettings.copyFormat));
      paletteItem.emitter.on("trash", (e2) => {
        e2.stopPropagation();
        const deletedIndex = this.colors.indexOf(color);
        let colors2 = this.colors;
        let settings2 = this.settings;
        colors2.splice(deletedIndex, 1);
        settings2.aliases.splice(deletedIndex, 1);
        this.emitter.emit("changed", colors2, settings2);
        this.reload();
      });
      paletteItem.emitter.on("alias", (alias) => {
        const aliasIndex = this.colors.findIndex((val) => val === color);
        for (let i3 = 0; i3 < aliasIndex; i3++) {
          if (!this.settings.aliases[i3])
            this.settings.aliases[i3] = "";
        }
        this.settings.aliases[aliasIndex] = alias;
      });
      this.paletteItems.push(paletteItem);
    }
  }
  /**
   * Create invalid palette based on palette status
   * @param type Palette status type
   */
  createInvalidPalette(type, message = "") {
    this.status = type;
    this.dropzone.style.setProperty("--palette-height", "150px");
    this.dropzone.style.setProperty("--palette-width", `100%`);
    const invalidSection = this.dropzone.createEl("section");
    invalidSection.toggleClass("invalid", true);
    const invalidSpan = invalidSection.createEl("span");
    let defaultMessage = "Invalid palette";
    switch (type) {
      case "Invalid Colors" /* INVALID_COLORS */:
        invalidSpan.setText("Invalid Colors" /* INVALID_COLORS */);
        defaultMessage = "Colors are defined incorrectly";
        this.createNotice(`Palette:
${message ? message : defaultMessage}`);
        break;
      case "Invalid Settings" /* INVALID_SETTINGS */:
        invalidSpan.setText("Invalid Settings" /* INVALID_SETTINGS */);
        defaultMessage = "Issues parsing settings";
        this.createNotice(`Palette:
${message ? message : defaultMessage}`);
        break;
      case "Invalid Colors & Settings" /* INVALID_COLORS_AND_SETTINGS */:
        invalidSpan.setText("Invalid Colors & Settings" /* INVALID_COLORS_AND_SETTINGS */);
        defaultMessage = "Colors and settings are defined incorrectly";
        this.createNotice(`Palette:
${message ? message : defaultMessage}`);
        break;
      case "Invalid Gradient" /* INVALID_GRADIENT */:
        invalidSpan.setText("Invalid Gradient" /* INVALID_GRADIENT */);
        defaultMessage = "Gradients require more than 1 color to display";
        this.createNotice(`Palette:
${message ? message : defaultMessage}`);
        break;
    }
    if (this.pluginSettings.errorPulse) {
      this.dropzone.style.setProperty("--notice-duration", (this.pluginSettings.noticeDuration / 1e3 / 2).toString() + "s");
      this.dropzone.toggleClass("palette-pulse", true);
      setTimeout(() => this.dropzone.toggleClass("palette-pulse", false), this.pluginSettings.noticeDuration);
    }
  }
};
var PaletteError = class extends Error {
  constructor(status, message = "") {
    super(message);
    this.status = status;
  }
};

// src/utils/generateUtils.ts
var Combination = /* @__PURE__ */ ((Combination2) => {
  Combination2["Complimentary"] = "Complimentary";
  Combination2["Monochromatic"] = "Monochromatic";
  Combination2["Analogous"] = "Analogous";
  Combination2["Triadic"] = "Triadic";
  Combination2["Tetradic"] = "Tetradic";
  Combination2["Random"] = "Random";
  return Combination2;
})(Combination || {});
function generateColors(combination, optional = { baseColor: Mt.random() }) {
  let { baseColor, settings } = optional;
  if (!baseColor)
    baseColor = Mt.random();
  let colors = [];
  switch (combination) {
    case "Complimentary" /* Complimentary */:
      colors = [baseColor.hex(), baseColor.complement().hex()];
      if (settings)
        settings.aliases = ["Base", "Complimentary Color"];
      break;
    case "Monochromatic" /* Monochromatic */:
      const lightest = baseColor.lighten(20);
      const lighter = baseColor.lighten(10);
      const darker = baseColor.darken(10);
      const darkest = baseColor.darken(20);
      colors = [lightest.hex(), lighter.hex(), baseColor.hex(), darker.hex(), darkest.hex()];
      if (settings)
        settings.aliases = ["Lightest", "Lighter", "Base", "Darker", "Darkest"];
      break;
    case "Analogous" /* Analogous */:
      const east = baseColor.adjustHue(-25);
      const west = baseColor.adjustHue(25);
      colors = [east.hex(), baseColor.hex(), west.hex()];
      if (settings)
        settings.aliases = ["Analogous East", "Base", "Analogous West"];
      break;
    case "Triadic" /* Triadic */:
      const hex120 = baseColor.spin(120);
      const hex240 = baseColor.spin(240);
      colors = [baseColor.hex(), hex120.hex(), hex240.hex()];
      if (settings)
        settings.aliases = ["Triadic First", "Base", "Triadic Third"];
      break;
    case "Tetradic" /* Tetradic */:
      const hex90 = baseColor.spin(90);
      const hex180 = baseColor.spin(180);
      const hex270 = baseColor.spin(270);
      colors = [baseColor.hex(), hex90.hex(), hex180.hex(), hex270.hex()];
      if (settings)
        settings.aliases = ["Base", "Tetradic Second", "Tetradic Third", "Tetradic Fourth"];
      break;
    case "Random" /* Random */:
      const randomNumber = Math.max(Math.round(Math.random() * 10), 2);
      let randomColors = [];
      for (let i2 = 0; i2 < randomNumber; i2++) {
        randomColors.push(Mt.random().hex());
      }
      colors = randomColors;
      if (settings)
        settings.aliases = [];
      break;
  }
  return { colors, settings };
}

// src/utils/imageUtils.ts
var import_quantize = __toESM(require_quantize());
var CanvasImage = class extends Canvas {
  constructor(container, imageURL, smoothing = false) {
    super(container);
    /**
     * Waits for loading variable to equal true
     */
    this.waitForLoading = () => new Promise((resolve) => {
      const checkLoading = setInterval(() => {
        if (!this.loading) {
          clearInterval(checkLoading);
          resolve(true);
        }
      }, 100);
    });
    this.canvas.addClass("image");
    this.loading = true;
    this.image = new Image();
    this.image.crossOrigin = "anonymous";
    if (imageURL)
      this.image.src = imageURL;
    this.image.addEventListener("load", (e2) => this.loading = false);
    this.image.addEventListener("error", (e2) => {
      throw new Error("The URL provided could not be loaded.");
    });
    this.context.imageSmoothingEnabled = smoothing;
  }
  /**
   * Updates & loads the canvas image.
   * Attempts to preserve aspect ratio based on width.
   * @param width The canvas width
   * @param height The canvas height
   */
  update(imageURL, width, height) {
    this.image.src = imageURL;
    this.waitForLoading().then(() => {
      const aspectRatio = this.image.naturalHeight / this.image.naturalWidth;
      let newWidth = width;
      let newHeight = newWidth * aspectRatio;
      if (newHeight > height) {
        newWidth = height / aspectRatio;
        newHeight = height;
      }
      this.width = this.canvas.width = newWidth;
      this.height = this.canvas.height = newHeight;
      this.context.drawImage(this.image, 0, 0, newWidth, newHeight);
    });
  }
  /**
   * Gets the most frequent colors in an image
   * @param numColors Number of colors to return
   * @param quality Artificially reduce number of pixels (higher = less accurate but faster)
   * @returns Most frequent colors
   */
  async getPalette(numColors = 7, quality = 10) {
    const nColors = numColors <= 7 ? numColors : numColors + 1;
    await this.waitForLoading();
    const pixels = await this.createPixelArray(quality);
    if (!pixels)
      return null;
    const colorMap = (0, import_quantize.default)(pixels, nColors);
    return colorMap ? colorMap.palette() : [];
  }
  /**
   * Creates an array of pixels from the image
   * Inspired by colorthief
   * @param quality Artificially reduce number of pixels (higher = less accurate but faster)
   * @returns 
   */
  async createPixelArray(quality) {
    var _a;
    await this.waitForLoading();
    const pixelArray = [];
    const imageData = (_a = await this.getImageData()) == null ? void 0 : _a.data;
    if (!imageData)
      return null;
    const pixelCount = this.height * this.width;
    for (let i2 = 0; i2 < pixelCount; i2 += quality) {
      const offset = i2 * 4;
      const [r2, g2, b2, a2] = [imageData[offset + 0], imageData[offset + 1], imageData[offset + 2], imageData[offset + 3]];
      if (typeof a2 === "undefined" || a2 >= 125) {
        if (!(r2 > 250 && g2 > 250 && b2 > 250)) {
          pixelArray.push([r2, g2, b2]);
        }
      }
    }
    return pixelArray;
  }
  /**
   * Gets the image data from the canvas
   */
  async getImageData(x2 = 0, y2 = 0) {
    try {
      await this.waitForLoading();
      return this.context.getImageData(x2, y2, this.width, this.height);
    } catch (e2) {
      throw new Error("Failed to get image data.");
    }
  }
};

// src/components/EditorModal.ts
var EditorModal = class extends import_obsidian5.Modal {
  constructor(app, pluginSettings, onSubmit, palette) {
    super(app);
    this.onSubmit = onSubmit;
    this.pluginSettings = pluginSettings;
    this.settings = pluginToPaletteSettings(pluginSettings);
    this.colors = [];
    this.selectedInput = "Color Picker" /* Color_Picker */;
    this.combination = "Random" /* Random */;
    this.baseColor = void 0;
    this.palette = palette;
    const resizeObserver = new ResizeObserver((modals) => {
      for (const modal of modals) {
        for (const child of Array.from(modal.target.children)) {
          if (child.hasClass("modal")) {
            for (const modalChild of Array.from(child.children)) {
              if (modalChild.hasClass("palette-editor")) {
                this.modalRect = modalChild.getBoundingClientRect();
              }
            }
          }
        }
      }
    });
    resizeObserver.observe(this.containerEl);
  }
  onOpen() {
    this.contentEl.createEl("h1", { text: "Editor" });
    this.contentEl.addClass("palette-editor");
    const colorsContainer = this.contentEl.createEl("section");
    colorsContainer.createEl("h3").setText("Colors");
    let controlContainer = colorsContainer.appendChild(createDiv());
    controlContainer.addClass("control-container");
    const previewContainer = this.contentEl.createEl("section");
    previewContainer.createEl("h3");
    const settingsContainer = this.contentEl.createEl("section");
    settingsContainer.createEl("h3").setText("Settings");
    const colorPickerBtn = new import_obsidian5.ButtonComponent(controlContainer).setIcon("pipette").setTooltip("Color Picker").onClick((e2) => {
      changeSelectedInput("Color Picker" /* Color_Picker */);
    });
    const generateBtn = new import_obsidian5.ButtonComponent(controlContainer).setIcon("shuffle").setTooltip("Generate").onClick((e2) => {
      changeSelectedInput("Generate" /* Generate */);
    });
    const imageBtn = new import_obsidian5.ButtonComponent(controlContainer).setIcon("image").setTooltip("Image").onClick((e2) => {
      changeSelectedInput("Image" /* Image */);
    });
    const urlBtn = new import_obsidian5.ButtonComponent(controlContainer).setIcon("link").setTooltip("URL").onClick((e2) => {
      changeSelectedInput("URL" /* URL */);
    });
    let addColorsContainer = colorsContainer.appendChild(createEl("div"));
    addColorsContainer.addClass("colors-container");
    function changeSelectedInput(selectedInput) {
      resetStyle();
      switch (selectedInput) {
        case "Color Picker" /* Color_Picker */:
          colorPickerBtn.setCta();
          addColorsContainer.empty();
          createColorPicker(addColorsContainer);
          addColorsContainer.toggleClass("select-color-picker", true);
          break;
        case "Generate" /* Generate */:
          generateBtn.setCta();
          addColorsContainer.empty();
          createGenerate(addColorsContainer);
          addColorsContainer.toggleClass("select-generate", true);
          break;
        case "Image" /* Image */:
          imageBtn.setCta();
          addColorsContainer.empty();
          createImage(addColorsContainer);
          addColorsContainer.toggleClass("select-image", true);
          break;
        case "URL" /* URL */:
          urlBtn.setCta();
          addColorsContainer.empty();
          createURL(addColorsContainer);
          addColorsContainer.toggleClass("select-url", true);
          break;
      }
      function resetStyle() {
        colorPickerBtn.removeCta();
        generateBtn.removeCta();
        imageBtn.removeCta();
        urlBtn.removeCta();
        addColorsContainer.toggleClass("select-color-picker", false);
        addColorsContainer.toggleClass("select-generate", false);
        addColorsContainer.toggleClass("select-image", false);
        addColorsContainer.toggleClass("select-url", false);
      }
    }
    const createColorPicker = (addColorsContainer2) => {
      let addColors = new import_obsidian5.Setting(addColorsContainer2).setName("Color Picker").setDesc("Use handpicked colors");
      const colorPickerInput = new import_obsidian5.ColorComponent(addColors.controlEl).onChange((value) => {
        this.colors.push(value);
        this.settings.aliases.push("");
        updatePalettePreview();
      });
    };
    const createGenerate = (addColorsContainer2) => {
      let addColors = new import_obsidian5.Setting(addColorsContainer2).setName("Generate").setDesc("Generate colors based on color theory");
      const dropdownInput = new import_obsidian5.DropdownComponent(addColors.controlEl);
      Object.keys(Combination).forEach((combination) => dropdownInput.addOption(combination, combination));
      dropdownInput.setValue(this.combination).onChange((value) => {
        this.combination = value;
        colorPickerInput.setDisabled(this.combination === "Random" /* Random */ ? true : false);
      });
      const colorPickerInput = new import_obsidian5.ColorComponent(addColors.controlEl).onChange((value) => {
        this.baseColor = Mt(value);
      }).setDisabled(this.combination === "Random" /* Random */ ? true : false);
      const colorPicker = Array.from(addColors.controlEl.children)[1];
      colorPicker.addEventListener("contextmenu", (e2) => {
        colorPickerInput.setValue(Mt("#000").hex());
        this.baseColor = void 0;
      });
      const buttonInput = new import_obsidian5.ButtonComponent(addColors.controlEl).setIcon("shuffle").setTooltip("Loads the generated colors").onClick((e2) => {
        const generated = generateColors(this.combination, { baseColor: this.baseColor, settings: this.settings });
        this.colors = generated.colors;
        if (generated.settings)
          this.settings = generated.settings;
        updatePalettePreview();
      });
    };
    const createImage = (addColorsContainer2) => {
      let fileURL = "";
      let addColors = new import_obsidian5.Setting(addColorsContainer2).setClass("add-colors").setName("Image").setDesc("Convert image into palette");
      const inputContainer = addColors.controlEl.appendChild(createEl("div"));
      const selectContainer = inputContainer.appendChild(createEl("div"));
      const urlInput = new import_obsidian5.TextComponent(selectContainer).setPlaceholder("Enter URL or select file").onChange((value) => fileURL = value);
      const loadButton = new import_obsidian5.ButtonComponent(selectContainer).setIcon("arrow-up-to-line").setTooltip("Right click to clear URL").onClick(async (e2) => {
        try {
          if (urlInput.getValue() !== "") {
            if (URL.canParse(urlInput.getValue()))
              await updateImagePreview(urlInput.getValue());
            else
              throw new Error("URL provided is not valid.");
          } else
            fileInput.click();
        } catch (e3) {
          new import_obsidian5.Notice(e3);
        }
      });
      loadButton.buttonEl.addEventListener("contextmenu", () => urlInput.setValue(""));
      const fileSelector = new import_obsidian5.TextComponent(selectContainer);
      const fileInput = fileSelector.inputEl;
      fileInput.type = "file";
      fileInput.accept = "image/*";
      fileInput.addEventListener("change", (e2) => {
        var _a;
        try {
          const reader = new FileReader();
          const file = (_a = e2.target.files) == null ? void 0 : _a[0];
          if (file)
            reader.readAsDataURL(file);
          reader.addEventListener("load", async () => {
            if (typeof reader.result === "string") {
              fileURL = reader.result;
              await updateImagePreview(fileURL);
            }
          });
          reader.addEventListener("error", () => {
            throw new Error("Error processing image.");
          });
        } catch (e3) {
          new import_obsidian5.Notice(e3);
        }
      });
      const sliderContainer = new import_obsidian5.Setting(addColorsContainer2).setName("Count").setDesc("Set the number of colors to generate from the image.");
      const countInput = new import_obsidian5.SliderComponent(sliderContainer.controlEl).setLimits(4, 12, 1).setDynamicTooltip().setValue(8).onChange(async (value) => await updateImagePreview(fileURL));
      const imageContainer = new import_obsidian5.Setting(addColorsContainer2);
      imageContainer.setClass("image-preview");
      imageContainer.setClass("hide-image-preview");
      let hex;
      const canvasImage = new CanvasImage(imageContainer.controlEl);
      canvasImage.canvas.style.setProperty("border-radius", this.pluginSettings.corners ? "5px" : "0px");
      canvasImage.canvas.addEventListener("mousemove", async (e2) => {
        hex = canvasImage.getCanvasHex(e2.clientX, e2.clientY);
      });
      canvasImage.canvas.addEventListener("click", (e2) => {
        if (!hex)
          return;
        this.colors.push(hex);
        this.settings.aliases.push("");
        updatePalettePreview();
      });
      canvasImage.image.addEventListener("load", () => {
        imageContainer.settingEl.toggleClass("hide-image-preview", false);
      });
      canvasImage.image.addEventListener("error", (e2) => {
        new import_obsidian5.Notice("The URL provided could not be loaded.");
      });
      const updateImagePreview = async (url) => {
        if (!url)
          return;
        canvasImage.update(url, this.modalRect.width, this.modalRect.height);
        const colors = await canvasImage.getPalette(countInput.getValue());
        if (colors) {
          this.colors = colors.map((color) => Mt(color).hex(0));
          this.settings.aliases = [];
          updatePalettePreview();
        }
      };
    };
    const createURL = (addColorsContainer2) => {
      let addColors = new import_obsidian5.Setting(addColorsContainer2).setName("URL").setDesc("Only coolors.co & colorhunt.co are currently supported.");
      const textInput = new import_obsidian5.TextComponent(addColors.controlEl).setPlaceholder("Enter URL");
      const buttonInput = new import_obsidian5.ButtonComponent(addColors.controlEl).setIcon("link").setTooltip("Right click to clear URL").onClick((e2) => {
        try {
          const urlText = textInput.getValue();
          if (!urlText.match(urlRegex))
            throw new Error("URL provided is not valid.");
          this.colors = parseUrl(urlText);
          this.settings.aliases = [];
          updatePalettePreview();
        } catch (e3) {
          new import_obsidian5.Notice(e3);
        }
      });
      buttonInput.buttonEl.addEventListener("contextmenu", () => {
        textInput.setValue("");
      });
    };
    changeSelectedInput(this.selectedInput);
    let palettePreview = previewContainer.appendChild(createDiv());
    palettePreview.addClass("palette-preview");
    const paletteContainer = palettePreview.appendChild(createDiv());
    this.colors = this.palette ? this.palette.colors : generateColors("Random" /* Random */).colors;
    this.settings = this.palette ? this.palette.settings : this.settings;
    const palette = new Palette(this.colors, this.settings, paletteContainer, this.pluginSettings, true);
    palette.emitter.on("changed", (colors, settings) => {
      let modifiedSettings = getModifiedSettings(settings);
      this.colors = colors;
      if (modifiedSettings)
        this.settings = { ...this.settings, ...modifiedSettings };
    });
    palettePreview.appendChild(palette.containerEl);
    const updatePalettePreview = () => {
      palette.colors = this.colors;
      palette.settings = this.settings;
      palette.reload();
    };
    new import_obsidian5.Setting(settingsContainer).setName("Height").addText((text) => {
      text.setValue(this.settings.height.toString()).onChange((value) => {
        try {
          if (!Number.isNaN(Number(value))) {
            this.settings.height = Number(value);
            updatePalettePreview();
          } else
            throw new Error("Please enter a number.");
        } catch (e2) {
          new import_obsidian5.Notice(e2);
        }
      });
    });
    new import_obsidian5.Setting(settingsContainer).setName("Width").setDesc("Caution - Might cause palette to display incorrectly.").addText((text) => {
      text.setValue(this.settings.width.toString()).onChange((value) => {
        try {
          if (!Number.isNaN(Number(value))) {
            this.settings.width = Number(value);
            updatePalettePreview();
          } else
            throw new Error("Please enter a number.");
        } catch (e2) {
          new import_obsidian5.Notice(e2);
        }
      });
    });
    new import_obsidian5.Setting(settingsContainer).setName("Direction").addDropdown((dropdown) => {
      dropdown.addOption("column" /* Column */, "column" /* Column */).addOption("row" /* Row */, "row" /* Row */).setValue(this.settings.direction.toString()).onChange((value) => {
        this.settings.direction = value;
        updatePalettePreview();
      });
    });
    new import_obsidian5.Setting(settingsContainer).setName("Gradient").addToggle((toggle) => {
      toggle.setValue(this.settings.gradient).onChange((value) => {
        this.settings.gradient = value;
        updatePalettePreview();
      });
    });
    new import_obsidian5.Setting(settingsContainer).setName("Hover").setDesc("Toggles whether palettes can be hovered").addToggle((toggle) => {
      toggle.setValue(this.settings.hover).onChange(async (value) => {
        this.settings.hover = value;
        updatePalettePreview();
      });
    });
    new import_obsidian5.Setting(settingsContainer).setName("Hide Text").setDesc("Disables color and alias visibility").addToggle((toggle) => {
      toggle.setValue(this.settings.hideText).onChange(async (value) => {
        this.settings.hideText = value;
        updatePalettePreview();
      });
    });
    new import_obsidian5.Setting(settingsContainer).setName("Override").setDesc("Disables color validation for full control (advanced)").addToggle((toggle) => {
      toggle.setValue(this.settings.override).onChange(async (value) => {
        this.settings.override = value;
        updatePalettePreview();
      });
    });
    new import_obsidian5.Setting(settingsContainer).addButton(
      (button) => button.setButtonText("Create").setCta().onClick(() => {
        try {
          if (this.colors.length === 0)
            this.colors = generateColors("Random" /* Random */).colors;
          this.onSubmit(this.colors, getModifiedSettings(this.settings));
          this.close();
        } catch (e2) {
          new import_obsidian5.Notice(e2);
        }
      })
    );
  }
  onClose() {
    var _a;
    (_a = this.palette) == null ? void 0 : _a.emitter.clear();
    this.contentEl.empty();
  }
};

// src/components/GenerateModal.ts
var import_obsidian6 = require("obsidian");
var import_validate_color2 = __toESM(require_lib());

// src/utils/editorUtils.ts
var EditorUtils = class {
  constructor(editor) {
    this.editor = editor;
  }
  /**
   * Replaces selection or text at the cursor
   * @param content The content to be inserted
   * @param insertAfter Inserts the content after the current line
   */
  insertContent(content, insertAfter = false) {
    this.setCursorPostCallback((line) => {
      this.editor.somethingSelected() ? this.editor.replaceSelection(content) : insertAfter ? this.insertLine(content, "after") : this.replaceLine(content, line);
    });
  }
  /**
   * Sets the cursor to a position after callback editor changes
   * @param callback Changes to perform to the editor
   * @param options.line Defaults to the current cursor line
   * @param options.offset The number of lines to offset (calculates during function unless user specified)
   */
  setCursorPostCallback(callback, { line = this.editor.getCursor().line, offset } = {}) {
    const preLinesCount = this.editor.lineCount();
    callback(line);
    const postLinesCount = this.editor.lineCount() - preLinesCount;
    offset = offset || postLinesCount;
    this.editor.setCursor({ ch: 0, line: line + offset });
  }
  /**
   * 
   * @param options.line The line to retrieve the last character index from
   * @param options.offset The offset used from the line (for example, 1 could be used to get the last character index on the line below the cursor)
   * @returns The last character's index on the line
   */
  getLastCh({ line = this.editor.getCursor().line, offset = 0 } = {}) {
    return this.editor.getLine(line + offset).length;
  }
  /**
   * Replaces a single line
   * @param content The content to replace the line with
   * @param line The line to replace
   */
  replaceLine(content, line) {
    const lineContent = this.editor.getLine(line);
    this.editor.replaceRange(content, { line, ch: 0 }, { line, ch: lineContent.length });
  }
  /**
   * Inserts content into editor before or after the line
   * @param content The content to insert
   * @param location Where to insert the content, before or after the line
   * @param options.line Defaults to cursor line
   * @param options.ch Defaults to 0
   */
  insertLine(content, location = "before", { line = this.editor.getCursor().line, ch = 0 } = {}) {
    if (location === "before") {
      this.editor.replaceRange(content, { line, ch });
    }
    if (location === "after") {
      this.editor.replaceRange(
        this.editor.lastLine() === line ? "\n" + content : content + "\n",
        { line: line + 1, ch }
      );
    }
  }
};

// src/components/GenerateModal.ts
var GenerateModal = class extends import_obsidian6.SuggestModal {
  constructor(app, editor, pluginSettings) {
    super(app);
    this.editor = editor;
    this.settings = pluginToPaletteSettings(pluginSettings);
  }
  // Returns all available suggestions.
  getSuggestions(query) {
    return Object.keys(Combination).filter(
      (combination) => combination.toLowerCase().includes(query.toLowerCase())
    );
  }
  // Renders each suggestion item.
  renderSuggestion(combination, el) {
    el.createEl("span", { text: combination });
  }
  // Perform action on the selected suggestion.
  onChooseSuggestion(combination, evt) {
    try {
      const selTextOrLine = this.editor.somethingSelected() ? this.editor.getSelection() : this.editor.getLine(this.editor.getCursor().line);
      const isLineEmpty = this.editor.getLine(this.editor.getCursor().line).length === 0;
      const isColor = (0, import_validate_color2.default)(selTextOrLine);
      const { colors, settings } = isColor ? generateColors(combination, { baseColor: Mt(selTextOrLine), settings: this.settings }) : generateColors(combination, { settings: this.settings });
      const newBlock = createPaletteBlock({ colors, settings: settings ? getModifiedSettings(settings) : void 0 });
      const editorUtils = new EditorUtils(this.editor);
      editorUtils.insertContent(newBlock, !isColor && !isLineEmpty);
    } catch (error) {
      new import_obsidian6.Notice(error);
    }
  }
};

// src/components/PaletteMRC.ts
var import_obsidian9 = require("obsidian");
var import_validate_color3 = __toESM(require_lib());

// src/components/ReorderModal.ts
var import_obsidian7 = require("obsidian");
var Reorder = /* @__PURE__ */ ((Reorder2) => {
  Reorder2["Hue"] = "Hue";
  Reorder2["Saturation"] = "Saturation";
  Reorder2["Lightness"] = "Lightness";
  Reorder2["Red"] = "Red";
  Reorder2["Green"] = "Green";
  Reorder2["Blue"] = "Blue";
  Reorder2["Alpha"] = "Alpha";
  return Reorder2;
})(Reorder || {});
var ReorderModal = class extends import_obsidian7.SuggestModal {
  constructor(app, palette, onSubmit) {
    super(app);
    this.palette = palette;
    this.onSubmit = onSubmit;
  }
  // Returns all available suggestions.
  getSuggestions(query) {
    return Object.keys(Reorder).filter(
      (combination) => combination.toLowerCase().includes(query.toLowerCase())
    );
  }
  renderSuggestion(order, el) {
    el.createEl("span", { text: order });
  }
  onChooseSuggestion(item, evt) {
    const csColors = this.palette.colors.map((color) => {
      return Mt(color);
    });
    let colors = [];
    switch (item) {
      case "Hue" /* Hue */:
        colors = csColors.sort((a2, b2) => a2.hue() - b2.hue()).map((color) => color.hex());
        break;
      case "Saturation" /* Saturation */:
        colors = csColors.sort((a2, b2) => a2.saturation() - b2.saturation()).map((color) => color.hex());
        break;
      case "Lightness" /* Lightness */:
        colors = csColors.sort((a2, b2) => a2.lightness() - b2.lightness()).map((color) => color.hex());
        break;
      case "Red" /* Red */:
        colors = csColors.sort((a2, b2) => a2.red() - b2.red()).map((color) => color.hex());
        break;
      case "Green" /* Green */:
        colors = csColors.sort((a2, b2) => a2.green() - b2.green()).map((color) => color.hex());
        break;
      case "Blue" /* Blue */:
        colors = csColors.sort((a2, b2) => a2.blue() - b2.blue()).map((color) => color.hex());
        break;
      case "Alpha" /* Alpha */:
        colors = csColors.sort((a2, b2) => a2.alpha() - b2.alpha()).map((color) => color.hex());
        break;
    }
    this.onSubmit(colors, getModifiedSettings(this.palette.settings));
  }
};

// src/components/PaletteMenu.ts
var import_obsidian8 = require("obsidian");
var PaletteMenu = class extends import_obsidian8.Menu {
  constructor(app, context, palette, onChange) {
    super();
    this.app = app;
    this.context = context;
    this.palette = palette;
    this.onChange = onChange;
    this.createMenu();
  }
  createMenu() {
    this.addItem((item) => {
      item.setTitle("Reorder").setIcon("arrow-left-right").onClick(() => {
        const modal = new ReorderModal(this.app, this.palette, (colors, settings) => this.onChange(colors, settings));
        modal.open();
        modal.setInstructions([
          { command: "\u2191\u2193", purpose: "to navigate" },
          { command: "\u21B5", purpose: "to use" },
          { command: "esc", purpose: "to dismiss" }
        ]);
        modal.setPlaceholder("Choose a space to reorder palette");
      });
    });
    this.addItem((item) => {
      item.setTitle("Edit Mode").setIcon("palette").onClick(async () => {
        new EditorModal(this.app, this.palette.pluginSettings, (colors, settings) => {
          try {
            const paletteSection = this.context.getSectionInfo(this.palette.containerEl);
            if (paletteSection) {
              this.onChange(colors, settings);
            }
          } catch (error) {
            new import_obsidian8.Notice(error);
          }
        }, this.palette).open();
      });
    });
    if (!this.palette.settings.gradient && this.palette.settings.direction !== "row" /* Row */) {
      this.addItem((item) => {
        item.setTitle("Quick Edit").setIcon("brush").setChecked(this.palette.getEditMode()).onClick(async () => {
          this.palette.setEditMode(!this.palette.getEditMode());
          this.palette.reload();
        });
      });
    }
    this.addSeparator();
    this.addItem((item) => {
      item.setTitle("Convert to RGB").setIcon("droplets").onClick(() => {
        const colors = this.palette.colors.map((color) => {
          const rgbColor = Mt(color).rgb();
          return `rgb(${rgbColor[0]}, ${rgbColor[1]}, ${rgbColor[2]})`;
        });
        this.onChange(colors, getModifiedSettings(this.palette.settings));
      });
    });
    this.addItem((item) => {
      item.setTitle("Convert to HSL").setIcon("droplets").onClick(() => {
        const colors = this.palette.colors.map((color) => {
          const hslColor = Mt(color).hsl();
          return `hsl(${hslColor[0]} ${hslColor[1]}% ${hslColor[2]}%)`;
        });
        this.onChange(colors, getModifiedSettings(this.palette.settings));
      });
    });
    this.addItem((item) => {
      item.setTitle("Convert to HEX").setIcon("droplets").onClick(() => {
        const colors = this.palette.colors.map((color) => {
          return Mt(color).hex(2);
        });
        this.onChange(colors, getModifiedSettings(this.palette.settings));
      });
    });
    this.addSeparator();
    const input = createPaletteBlock({ colors: this.palette.colors, settings: getModifiedSettings(this.palette.settings) });
    this.addItem((item) => {
      item.setTitle("Cut").setIcon("scissors").onClick(async () => {
        await copyToClipboard(input, this.palette.pluginSettings.copyFormat);
        this.onChange(void 0, void 0);
      });
    });
    this.addItem((item) => {
      item.setTitle("Copy").setIcon("copy").onClick(async () => {
        await copyToClipboard(input, this.palette.pluginSettings.copyFormat);
      });
    });
  }
};

// src/components/PaletteMRC.ts
var PaletteMRC = class extends import_obsidian9.MarkdownRenderChild {
  constructor(plugin, containerEl, input, context) {
    super(containerEl);
    this.plugin = plugin;
    this.pluginSettings = plugin.settings;
    this.input = input;
    this.context = context;
  }
  onload() {
    var _a;
    this.update();
    (_a = this.plugin.palettes) == null ? void 0 : _a.push(this);
    this.containerEl.addEventListener("contextmenu", (e2) => {
      if (this.palette.status === "Valid" /* VALID */) {
        const paletteMenu = new PaletteMenu(this.plugin.app, this.context, this.palette, (colors, settings) => {
          if (colors == void 0)
            this.setPaletteInput("");
          else
            this.setPaletteInput(createPaletteBlock({ colors, settings }));
        });
        paletteMenu.showAtMouseEvent(e2);
      }
    });
  }
  unload() {
    var _a;
    this.palette.unload();
    (_a = this.plugin.palettes) == null ? void 0 : _a.remove(this);
  }
  /**
   * Updates the palette contents
   */
  update() {
    this.containerEl.empty();
    const { colors, settings } = this.calcColorsAndSettings(this.input);
    if (typeof colors !== "string" && typeof settings !== "string")
      this.editModeChanges = { colors, settings };
    this.palette = new Palette(colors, settings, this.containerEl, this.pluginSettings);
    this.palette.emitter.on("changed", (colors2, settings2) => {
      const modifiedSettings = getModifiedSettings(settings2);
      this.editModeChanges = { colors: colors2, settings: modifiedSettings };
    });
    this.palette.emitter.on("editMode", (editMode) => {
      if (!editMode) {
        this.setPaletteInput(createPaletteBlock({ colors: this.editModeChanges.colors, settings: this.editModeChanges.settings }));
      }
    });
  }
  /**
   * Parses input & extracts settings
   * @param input settings from codeblock
   * @returns PaletteSettings or Status if settings are not valid
   */
  parseSettings(input) {
    try {
      return JSON.parse(input);
    } catch (error) {
      return "Invalid Settings" /* INVALID_SETTINGS */;
    }
  }
  /**
   * Parses input & extracts colors based on color space or URL
   * @param input colors from codeblock
   * @returns Array of colors or Status if colors are not valid
   */
  parseColors(input, override) {
    let colors = input.flatMap((color) => {
      if (color.includes("(")) {
        return color.split(";").flatMap((postSplitColor) => postSplitColor.trim()).filter((color2) => color2 !== "");
      }
      return color.split(",").flatMap((postSplitColor) => {
        return postSplitColor.trim();
      });
    }).flatMap((color) => color.trim().replace(";", ""));
    const rawColors = colors.join("");
    if (rawColors.match(urlRegex))
      return parseUrl(rawColors);
    if (!override) {
      for (let color of colors) {
        if (!(0, import_validate_color3.default)(color))
          return "Invalid Colors" /* INVALID_COLORS */;
      }
    }
    return colors;
  }
  /**
   * Calculates colors and settings based on codeblock contents
   */
  calcColorsAndSettings(input) {
    const split = input.split("\n");
    const hasSettings = split.some((val) => val.includes("{"));
    let settings = hasSettings ? this.parseSettings(split.pop() || "") : void 0;
    let settingsObj = typeof settings === "object" ? settings : pluginToPaletteSettings(this.pluginSettings);
    return { colors: this.parseColors(split, settingsObj.override), settings };
  }
  /**
   * Gets the palette codeblock input
   */
  getPaletteInput() {
    var _a;
    let editor = (_a = this.plugin.app.workspace.getActiveViewOfType(import_obsidian9.MarkdownView)) == null ? void 0 : _a.editor;
    const paletteSection = this.context.getSectionInfo(this.palette.containerEl);
    if (paletteSection && editor)
      return {
        lines: {
          lineStart: paletteSection.lineStart,
          lineEnd: paletteSection.lineEnd
        },
        input: editor.getRange(
          { line: paletteSection.lineStart, ch: 0 },
          { line: paletteSection.lineEnd + 1, ch: 0 }
        )
      };
    else {
      this.createNotice("The editor has not fully loaded yet.");
    }
  }
  /**
   * Sets the palette codeblock input with `replacement`
   */
  setPaletteInput(replacement) {
    var _a;
    let editor = (_a = this.plugin.app.workspace.getActiveViewOfType(import_obsidian9.MarkdownView)) == null ? void 0 : _a.editor;
    const paletteSection = this.context.getSectionInfo(this.palette.containerEl);
    if (paletteSection && editor) {
      editor.replaceRange(replacement, { line: paletteSection.lineStart, ch: 0 }, { line: paletteSection.lineEnd + 1, ch: 0 });
      return {
        lineStart: paletteSection.lineStart,
        lineEnd: paletteSection.lineEnd
      };
    } else {
      this.createNotice("The editor has not fully loaded yet.");
    }
  }
  /**
   * Creates a new notice using pre-set settings
   * @param message Message to display
   */
  createNotice(message) {
    new import_obsidian9.Notice(message, this.pluginSettings.noticeDuration);
  }
};

// src/main.ts
var urlRegex = /(?:https:\/\/www\.|http:\/\/www\.|https:\/\/|http:\/\/)?[a-zA-Z0-9]{2,}(?:\.[a-zA-Z0-9]{2,})(?:\.[a-zA-Z0-9]{2,})?\/(?:palette\/)?([a-zA-Z0-9-]{2,})/;
var ColorPalette2 = class extends import_obsidian10.Plugin {
  async onload() {
    this.palettes = [];
    await this.loadSettings();
    this.registerMarkdownCodeBlockProcessor(
      "palette",
      async (source, el, ctx) => {
        ctx.addChild(new PaletteMRC(this, el, source.trim(), ctx));
      }
    );
    this.addCommand({
      id: "create",
      name: "Create",
      editorCallback: (editor) => {
        new EditorModal(this.app, this.settings, (colors, settings) => {
          try {
            const result = createPaletteBlock({ colors, settings });
            const cursor = editor.getCursor();
            editor.transaction({
              changes: [{ from: cursor, text: result }]
            });
            editor.setCursor({
              line: cursor.line + result.split("\n").length,
              ch: 0
            });
            new import_obsidian10.Notice(`Added ${result}`);
          } catch (error) {
            new import_obsidian10.Notice(error);
          }
        }).open();
      }
    });
    this.addCommand({
      id: "convert-link",
      name: "Convert link",
      editorCallback: async (editor) => {
        try {
          let link = "";
          const editorSelection = editor.getSelection();
          const clipboardText = await navigator.clipboard.readText();
          if (editorSelection.match(`^${urlRegex.source}$`))
            link = editorSelection;
          else if (clipboardText.match(`^${urlRegex.source}$`))
            link = clipboardText;
          else
            throw new Error("Failed to convert link. Please select or copy a link, then try again.");
          const codeBlock = createPaletteBlock(link);
          const cursor = editor.getCursor();
          editor.replaceSelection(codeBlock);
          editor.setCursor({
            line: cursor.line + codeBlock.split("\n").length,
            ch: 0
          });
          new import_obsidian10.Notice(`Converted ${editorSelection || clipboardText}`);
        } catch (error) {
          new import_obsidian10.Notice(error);
        }
      }
    });
    this.addCommand({
      id: "convert-codeblock-link-to-hex",
      name: "Convert codeblock link to hex",
      editorCallback: (editor) => {
        var _a, _b, _c;
        try {
          const codeBlock = editor.getSelection();
          const multiReg = RegExp(/(?:\`{3}palette)\n(?<url>.*)(?:\n(?<settings>.+))?\n\`{3}/, "g");
          const content = (_b = (_a = [...codeBlock.matchAll(multiReg)]) == null ? void 0 : _a[0]) == null ? void 0 : _b.slice(1);
          const url = content == null ? void 0 : content[0];
          if (!url)
            throw new Error("Selected text is not a codeblock with a link.");
          let colors = [];
          url.match(urlRegex) && url.includes("-") ? colors = url.substring(url.lastIndexOf("/") + 1).split("-").map((i2) => "#" + i2) : (
            // Check if link (colorhunt)
            url.match(urlRegex) ? colors = ((_c = url.substring(url.lastIndexOf("/") + 1).match(/.{1,6}/g)) == null ? void 0 : _c.map((i2) => "#" + i2)) || ["Invalid Palette"] : colors = ["Invalid Palette"]
          );
          if (colors[0] === "Invalid Palette")
            throw new Error("Selected codeblock can not be converted to hex.");
          let newBlock;
          if (!(content == null ? void 0 : content[1])) {
            newBlock = createPaletteBlock({ colors });
          } else {
            const settings = JSON.parse(content[1]);
            createPaletteBlock({ colors, settings });
          }
          if (newBlock) {
            editor.replaceSelection(newBlock);
            new import_obsidian10.Notice(`Converted codeblock link to hex`);
          } else
            throw new Error("Selected codeblock can not be converted to hex.");
        } catch (error) {
          new import_obsidian10.Notice(error);
        }
      }
    });
    this.addCommand({
      id: "generate-random-palette",
      name: "Generate random palette",
      editorCallback: (editor) => {
        new GenerateModal(this.app, editor, this.settings).open();
      }
    });
    this.addSettingTab(new SettingsTab(this.app, this));
  }
  async loadSettings() {
    this.settings = Object.assign({}, defaultSettings, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
};


/* nosourcemap */
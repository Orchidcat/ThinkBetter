https://www.red-gate.com/simple-talk/databases/sql-server/database-administration-sql-server/sql-server-storage-internals-101/


### row

行是 SQL Server 数据文件中最小的存储结构。表中的每一行都作为单独的记录存储在磁盘上。不仅表数据以记录形式存储，索引、元数据、数据库启动结构等等也以记录形式存储。不过，我们只讨论最常见、最重要的记录类型，即**数据记录**，它与索引记录的格式相同。


数据记录以某种格式存储`fixedvar` ； 固定长度和可变长度；

固定长度数据类型具有固定的长度，且不会偏离该长度。
可变长度数据类型得长度会根据记录而变化。


![[Pasted image 20250604091155.png]]

每个数据记录都以两个状态字节开始：
- 记录类型 - 其中**数据**和**索引**类型是最常见和最重要的。
- 记录是否有空位图 - 用于跟踪列是否具有空值的一个或多个字节
- 记录是否有任何可变长度的列

两个字节存储记录中固定长度部分的总长度。这是实际固定长度数据的长度，加上用于存储状态的2个字节，以及用于存储总固定长度的2个字节。有时我们将固定长度字段称为空位图指针（ null bitmap pointer )，因为它指向固定长度数据的末尾，也就是空位图的起始位置。

固定长度数据中还将固定长度类型的所有列数据，记录在了 table schema中。这些列按物理顺序存储，因此，通过计算模式中所有先前固定长度列的大小，始终可以将其定位在数据记录中的特定字节索引处。

接下来的两个存储区域组成了空位图（null bitmap); 这是一个位数组，用于跟踪哪些列对该记录包含空值，以及哪些列在记录中具有非空值。由于固定长度的数据列始终占用其分配的空间，因此我们需要空位图来知道值是否为空。对于可变长度的列，空位图是我们区分 `empty value` 和 `null value` 的方法。

实际位图前面的 2 个字节仅存储位图跟踪的列数。由于位图中的每一列都需要一个位，因此可以通过将总列数除以 8，然后向上舍入到最接近的整数来计算空位图所需的字节数 `CEIL(#Cols /8)`

最后，我们得到记录的可变长度部分，它由 2 个字节组成，用于存储可变长度列的数量，后面跟着一个**可变长度偏移量数组**，最后是实际的可变长度数据。

![[Pasted image 20250604095129.png]]

两个字节开始，它们表示记录中存储的可变长度列的数量。在本例中，值`0x0200`表示两列。接下来是一系列双字节值，它们构成可变长度偏移量数组，每列一个，指向记录中相关列数据结束的字节索引。最后，我们得到了实际的可变长度列。

由于 SQL Server 知道数据从偏移数组中的最后一个条目之后开始，并且知道每列的数据在何处结束，因此它可以计算每列的长度，以及查询数据。


### Page

理论上，SQL Server 可以将十亿条记录并排存储在一个大型数据文件中，但这管理起来会很麻烦。相反，它会以更小的数据单位（称为页）来组织和存储记录。

页也是 SQL Server 在内存中缓存（由缓冲区管理器处理）的最小数据单位。

页面类型各有不同；有些用于存储数据记录，有些用于存储索引记录，还有一些用于存储各种元数据。它们都有一个共同点，那就是它们的结构。一个页面的**大小始终**恰好为 **8 KB**（8192 字节），

包含两个主要部分：page head 和 page body 。
页头的大小固定为 96 字节，并且无论页面类型如何，其内容和格式都相同。
页头包含的信息包括页体中有多少可用空间、页体中存储了多少条记录、页面所属的对象，以及在索引中，页体前后的页面。

page body 占用剩余的8096个字节。
![[Pasted image 20250604095524.png]]

page body 最末端记录偏移量数组。它是 SQL Server 从页面的最末端反向读取的双字节值数组。

头部包含一个字段，该字段定义记录偏移量数组中存在的**槽**数（ slots )，从而定义 SQL Server 可以读取的双字节值的数量。 记录偏移量数组中的每个槽都指向页面中记录开始的字节索引。

记录偏移量数组决定了记录的**物理顺序**。

因此，页面上的最后一条记录在逻辑上很可能就是物理上的第一条记录。通常，您会发现记录偏移量数组的第一个槽（存储在页面的最后两个字节中）指向存储在字节索引 96 处的第一条记录，该记录位于主体的最开始，紧跟在标头之后。


使用DBCC ，可以看到格式为 （ X :Y:Z) 的 record pointer;
指向数据文件`X`、页面`Y`和槽`Z`。要查找页面 上的记录`Y`，SQL Server 首先需要找到具有 id 的数据文件的路径`X`。该文件只是一个大页面数组，第一页从字节索引 0 开始，下一页从字节索引 8192 开始，第三页从字节索引 16384 开始，依此类推。页码直接与字节索引相关，其中页面 0 存储在字节索引处`0*8192`，页面 1 存储在字节索引 处`1*8192`，页面 2 存储在字节索引处，`2*8192`依此类推。因此，要找到页面 Y 的内容，SQL Server 需要从字节索引 开始读取 8192 个字节`Y*8192`。读取页面的字节后，SQL Server 可以读取`Z`记录偏移量数组中的条目，以找出记录字节存储在主体中的位置。


### 使用DBCC 命令调查页面内容

`DBCC TRACEON`、[[DBCC PAGE]] 以及 [[DBCC IND]]

`DBCC IND`为数据库中的任何对象提供相关的页面 ID，然后`DBCCPAGE`允许我们调查这些特定页面在磁盘上存储的内容。请注意，`DBCC PAGE`和`IND`都是只读操作，因此使用起来完全安全。


## Heap and Index

没有聚集索引的表，就是Heap；如果表包含聚集索引，则该表的存储方式与索引相同。

### Heap
堆是最简单的数据结构，因为它们只是“一大堆页面”，所有页面都属于同一个对象。一种称为**索引分配映射**(IAM) 的特殊页面类型会跟踪哪些页面属于哪个对象。SQL Server 将 IAM 页面用于堆和索引，但它们对于堆尤其重要，因为它们是查找包含堆数据的页面的唯一机制。本文的主要目标是讨论索引的结构和设计，因此我将仅简要介绍堆。

每个 IAM 页包含一个巨大的位图，可跟踪 511,232 个页面，或大约 4 GB 的数据。为了提高效率，IAM 页并不跟踪单个页面，而是以 8 个页面为一组，称为 **“区”** （ extents ) 。如果堆占用的数据超过 4 GB，SQL Server 会分配另一个 IAM 页，以便跟踪接下来 4 GB 数据中的页面，并在第一个 IAM 页的页头中保留指向下一个 IAM 页的指针。为了扫描堆，SQL Server 只需找到第一个 IAM 页，然后扫描它指向的每个区中的每个页面。

需要记住的一个重要事实是，**堆不保证每个页面内的记录顺序**。SQL Server 会将新记录插入到它想要的任何位置，通常是在具有足够空间的现有页面上，或者在新分配的页面上。

与索引相比，堆在维护方面相当简单，因为无需维护物理顺序。我们无需考虑诸如使用不断增加的键来在插入行时维护顺序之类的因素；SQL Server 只会在其所选页面上的任何合适位置附加记录，而不管键是什么。

然而，仅仅因为堆维护有限，并不意味着堆没有维护问题。为了理解其中的原因，我们需要讨论一下**转发记录**  (**forwarded records**)。

与索引不同，堆没有唯一标识给定记录的键。如果非聚集索引或外键需要指向特定记录，它会使用指向其物理位置的指针（表示为 ( `FileID` `:PageID:SlotID`) ，也称为**RID**或**行标识符**）来实现。例如， ( `1:16:2`) 指向第一个文件（从索引 1 开始）中第 17 页（均从索引 0 开始）的第三个位置。

想象一下，指向记录 () 的指针`1:16:2`存在于 20 个不同的地方，但可能由于某个列值的更新，SQL Server 必须将该记录从第 16 页移出，因为第 16 页已经没有空间容纳它了。这带来了一个有趣的性能问题。

如果 SQL Server 只是将记录移动到新的物理位置，它将不得不在 20 个不同的位置更新该物理指针，这会带来很大的工作量。相反，它会将记录复制到一个新页面，并将原始记录转换为转发存根 ( **forwarding stub)**，这是一个仅占用 9 个字节的小记录，用于存储指向新记录的物理指针。现有的 20 个物理指针将读取转发存根，从而使 SQL Server 能够找到所需的数据。

这种技术使更新更简单、更快捷，但代价是读取时需要进行额外的查找。随着数据修改导致越来越多的记录被转发，磁盘 I/O 会急剧增加，因为 SQL Server 会尝试从整个磁盘读取记录。


```SQL
SELECT o.name ,
       ps.forwarded_record_count
FROM
       sys.dm_db_index_physical_stats(DB_ID('AdventureWorks2008R2'),NULL, NULL,NULL, 'DETAILED') ps
INNER JOIN sys.objects o ON o.object_id = ps.object_id
WHERE forwarded_record_count > 0
```

查找`AdventureWorks`数据库中所有包含转发记录的堆。如果确实存在任何堆（但愿没有），请监视这些值以决定何时发出`ALTER TABLE REBUILD`命令来删除转发记录。
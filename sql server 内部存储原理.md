https://www.red-gate.com/simple-talk/databases/sql-server/database-administration-sql-server/sql-server-storage-internals-101/


### row

行是 SQL Server 数据文件中最小的存储结构。表中的每一行都作为单独的记录存储在磁盘上。不仅表数据以记录形式存储，索引、元数据、数据库启动结构等等也以记录形式存储。不过，我们只讨论最常见、最重要的记录类型，即**数据记录**，它与索引记录的格式相同。


数据记录以某种格式存储`fixedvar` ； 固定长度和可变长度；

固定长度数据类型具有固定的长度，且不会偏离该长度。
可变长度数据类型得长度会根据记录而变化。


![[Pasted image 20250604091155.png]]

每个数据记录都以两个状态字节开始：
- 记录类型 - 其中**数据**和**索引**类型是最常见和最重要的。
- 记录是否有空位图 - 用于跟踪列是否具有空值的一个或多个字节
- 记录是否有任何可变长度的列

两个字节存储记录中固定长度部分的总长度。这是实际固定长度数据的长度，加上用于存储状态的2个字节，以及用于存储总固定长度的2个字节。有时我们将固定长度字段称为空位图指针（ null bitmap pointer )，因为它指向固定长度数据的末尾，也就是空位图的起始位置。

固定长度数据中还将固定长度类型的所有列数据，记录在了 table schema中。这些列按物理顺序存储，因此，通过计算模式中所有先前固定长度列的大小，始终可以将其定位在数据记录中的特定字节索引处。

接下来的两个存储区域组成了空位图（null bitmap); 这是一个位数组，用于跟踪哪些列对该记录包含空值，以及哪些列在记录中具有非空值。由于固定长度的数据列始终占用其分配的空间，因此我们需要空位图来知道值是否为空。对于可变长度的列，空位图是我们区分 `empty value` 和 `null value` 的方法。

实际位图前面的 2 个字节仅存储位图跟踪的列数。由于位图中的每一列都需要一个位，因此可以通过将总列数除以 8，然后向上舍入到最接近的整数来计算空位图所需的字节数 `CEIL(#Cols /8)`

最后，我们得到记录的可变长度部分，它由 2 个字节组成，用于存储可变长度列的数量，后面跟着一个**可变长度偏移量数组**，最后是实际的可变长度数据。

![[Pasted image 20250604095129.png]]

两个字节开始，它们表示记录中存储的可变长度列的数量。在本例中，值`0x0200`表示两列。接下来是一系列双字节值，它们构成可变长度偏移量数组，每列一个，指向记录中相关列数据结束的字节索引。最后，我们得到了实际的可变长度列。

由于 SQL Server 知道数据从偏移数组中的最后一个条目之后开始，并且知道每列的数据在何处结束，因此它可以计算每列的长度，以及查询数据。


### Page

理论上，SQL Server 可以将十亿条记录并排存储在一个大型数据文件中，但这管理起来会很麻烦。相反，它会以更小的数据单位（称为页）来组织和存储记录。

页也是 SQL Server 在内存中缓存（由缓冲区管理器处理）的最小数据单位。



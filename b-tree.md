#SQLServer/Internal 


B 树结构是一种页面树，通常被形象化为倒置的树，从顶部开始，**分支到**中间**级别，最后到达底部级别，即**叶级别**。

如果索引的所有记录都适合放在一页上，则树只有一层，因此根级别和叶级别在技术上可以是同一级别。一旦索引需要两页，树就会分裂成一个根页面，指向叶级别的两个子页面。对于聚集索引，叶级别是 SQL Server 存储所有数据的地方；树的所有中间（即非叶）级别仅包含来自关键列的数据。键越小，这些分支页面上可以容纳的记录越多，从而导致树的深度更浅，叶查找速度更快。

![[Pasted image 20250604110457.png]]

具有整数键的索引的 B 树结构。


您可能听过一句古老的谚语：扫描不好，搜索好，这是有充分理由的，因为总的来说，这些都是明智之言。

如前所述，堆中的数据没有顺序，因此如果 SQL Server 想要查找特定值，它只能通过扫描堆中的_所有_`SELECT TOP 1`数据来实现。即使我们运行“ ”查询，如果结果集的第一行恰好是堆中的最后一条记录，SQL Server 仍可能需要扫描整个表才能返回该行。当然，如果堆上恰好有一个包含所需列的非聚集索引，SQL Server 可能会执行查找操作。

相反，在 B 树中查找特定值非常高效。利用 B 树按索引键对所有值进行逻辑排序的特性，我们可以使用一种称为**二分查找的**算法，只需很少的操作就能找到所需的值。

想象一下这样一个游戏：玩家 A 想出一个 1 到 10 之间的数字，让玩家 B 猜。玩家 B 每次猜测，玩家 A 只能给出三个答案之一：“正确”、“小于”或“大于”。

玩家A想出一个数字。玩家B是一位聪明的对手，他问这个数字是不是“5”。玩家B回答“更大”，所以B现在知道这个数字是6、7、8、9或10。B再次瞄准中间值，猜“8”。A回答“更大”，所以B现在知道这个数字要么是9，要么是10。B猜“9”，A回答“正确”。通过始终选择中间值，玩家B每次猜测时都将数值数量减半，从而迅速缩小了可能的范围。

SQL Server 使用类似的逻辑来遍历 B 树以查找特定值。假设 SQL Server 在响应查询时需要找到与图 4 中的键 5 对应的记录。首先，它会查看根页面上的中间键 17，这表明它指向的页面包含 17 及更高的值。5 小于 17，因此它会检查所有低于 17 的键的中间键。在这个简单的例子中，只有_Ã_键，因此它会沿着此链接进入下一级页面并检查中间键的值。由于只有两个键，它会向上舍入，查看最右边的键（保存值 4），然后沿着链找到包含键 4 和 5 的叶级页面，此时它就找到了所需的键。

相反，如果搜索的是键 22，SQL Server 会以相同的方式启动，但这次，在搜索到键 17 之后，会检查所有键值高于 17 的键的中间键。由于只找到键 23，而键值太高，因此 SQL Server 得出结论：键 17 指向的第二层页面包含值 17-22。从这里开始，SQL Server 沿着唯一可用的键向下查找到叶级，却找不到值 22，因此得出结论：没有行符合搜索条件。

## 缺点
SQL Server 必须确保记录始终按正确的键顺序排序。在图 5 中，左侧是一棵非常小的树，仅使用一个整数作为键。它包含两层，由一个根页面和两个子页面组成。我们假设每个叶级页面除了键之外还包含大量数据，因此不能容纳超过两条记录。如果我们要插入值 15，SQL Server 必须引入第三个叶级页面。它不能直接在末尾的第三个页面上添加新行，因为它必须将值 15 插入到 10 和 20 之间。这会导致**页面拆分**。SQL Server 只需将包含值 10 和 20 的现有页面拆分为两个页面，将一半的行存储在新页面上，将另一半存储在原始页面上。现在，SQL Server 有足够的空间将值 15 插入到半空的原始页面（包含值 10）中。

![[Pasted image 20250604111007.png]]

页面拆分后，我们现在在叶级有三个页面，在根页面中有三个键。与简单地在现有页面上插入记录相比，页面拆分本身对 SQL Server 来说是一项成本高昂的操作，但真正的成本体现在页面拆分产生的碎片上。我们不再拥有物理上连续的页面列表；SQL Server 可能会将新分配的页面存储在完全不同的磁盘区域中。因此，当我们扫描树时，我们必须读取第一个页面，可能会跳转到磁盘上完全不同的部分，然后再返回继续按顺序读取页面。

随着时间的推移和碎片化的加剧，你会发现性能会逐渐下降。插入操作很可能以线性速度运行，但扫描和查找操作会逐渐变慢。

避免此问题的一个简单方法是避免在现有行之间插入新行。如果我们使用不断增加的标识值作为键，我们总是将行添加到末尾，SQL Server 就无需拆分现有页面。如果我们删除现有行，我们仍然会得到半满的页面，但这样可以避免页面在磁盘上不连续地存储。
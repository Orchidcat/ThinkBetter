#SQLServer/Internal 


B 树结构是一种页面树，通常被形象化为倒置的树，从顶部开始，**分支到**中间**级别，最后到达底部级别，即**叶级别**。

如果索引的所有记录都适合放在一页上，则树只有一层，因此根级别和叶级别在技术上可以是同一级别。一旦索引需要两页，树就会分裂成一个根页面，指向叶级别的两个子页面。对于聚集索引，叶级别是 SQL Server 存储所有数据的地方；树的所有中间（即非叶）级别仅包含来自关键列的数据。键越小，这些分支页面上可以容纳的记录越多，从而导致树的深度更浅，叶查找速度更快。

![[Pasted image 20250604110457.png]]

具有整数键的索引的 B 树结构。


您可能听过一句古老的谚语：扫描不好，搜索好，这是有充分理由的，因为总的来说，这些都是明智之言。

如前所述，堆中的数据没有顺序，因此如果 SQL Server 想要查找特定值，它只能通过扫描堆中的_所有_`SELECT``TOP``1`数据来实现。即使我们运行“ ”查询，如果结果集的第一行恰好是堆中的最后一条记录，SQL Server 仍可能需要扫描整个表才能返回该行。当然，如果堆上恰好有一个包含所需列的非聚集索引，SQL Server 可能会执行查找操作。

相反，在 B 树中查找特定值非常高效。利用 B 树按索引键对所有值进行逻辑排序的特性，我们可以使用一种称为**二分查找的**算法，只需很少的操作就能找到所需的值。

想象一下这样一个游戏：玩家 A 想出一个 1 到 10 之间的数字，让玩家 B 猜。玩家 B 每次猜测，玩家 A 只能给出三个答案之一：“正确”、“小于”或“大于”。

玩家A想出一个数字。玩家B是一位聪明的对手，他问这个数字是不是“5”。玩家B回答“更大”，所以B现在知道这个数字是6、7、8、9或10。B再次瞄准中间值，猜“8”。A回答“更大”，所以B现在知道这个数字要么是9，要么是10。B猜“9”，A回答“正确”。通过始终选择中间值，玩家B每次猜测时都将数值数量减半，从而迅速缩小了可能的范围。

SQL Server 使用类似的逻辑来遍历 B 树以查找特定值。假设 SQL Server 在响应查询时需要找到与图 4 中的键 5 对应的记录。首先，它会查看根页面上的中间键 17，这表明它指向的页面包含 17 及更高的值。5 小于 17，因此它会检查所有低于 17 的键的中间键。在这个简单的例子中，只有_Ã_键，因此它会沿着此链接进入下一级页面并检查中间键的值。由于只有两个键，它会向上舍入，查看最右边的键（保存值 4），然后沿着链找到包含键 4 和 5 的叶级页面，此时它就找到了所需的键。

相反，如果搜索的是键 22，SQL Server 会以相同的方式启动，但这次，在搜索到键 17 之后，会检查所有键值高于 17 的键的中间键。由于只找到键 23，而键值太高，因此 SQL Server 得出结论：键 17 指向的第二层页面包含值 17-22。从这里开始，SQL Server 沿着唯一可用的键向下查找到叶级，却找不到值 22，因此得出结论：没有行符合搜索条件。

